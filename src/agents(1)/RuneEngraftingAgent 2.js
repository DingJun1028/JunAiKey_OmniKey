var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/RuneEngraftingAgent.ts\n// \u7B26\u6587\u9444\u9020\u4EE3\u7406 (Rune Engrafting Agent)\n// Handles operations related to Runes (registration, discovery, execution, installation, configuration).\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates Rune management and interaction logic.\n// --- Modified: Add operations for runes (register, list, executeAction, install, uninstall, updateConfiguration) --\n// --- New: Implement event listeners for rune events --\n// --- Modified: Update handleMessage to delegate to SacredRuneEngraver --\n\n\nimport { SystemContext, Rune } from '../../interfaces'; // Import types\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { SacredRuneEngraver } from '../core/rune-engrafting/SacredRuneEngraver'; // Access via context\n\n\nexport class RuneEngraftingAgent extends BaseAgent {\n    // private sacredRuneEngraver: SacredRuneEngraver; // Access via context\n\n\n    constructor(context: SystemContext) {\n        super('rune_engrafting', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Rune Engrafting Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[RuneEngraftingAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events from SacredRuneEngraver if needed (e.g., 'rune_registered', 'rune_uninstalled')\n            // This agent might need to react to these events, although the UI also listens directly.\n            // Example: this.context.eventBus.subscribe('rune_registered', (payload) => this.handleRuneRegistered(payload));\n\n        } catch (error) {\n            console.error('[RuneEngraftingAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Rune Engrafting Agent.\n     * Performs operations by delegating to the SacredRuneEngraver.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("], ["typescript\n// src/agents/RuneEngraftingAgent.ts\n// \\u7b26\\u6587\\u9444\\u9020\\u4ee3\\u7406 (Rune Engrafting Agent)\n// Handles operations related to Runes (registration, discovery, execution, installation, configuration).\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates Rune management and interaction logic.\n// --- Modified: Add operations for runes (register, list, executeAction, install, uninstall, updateConfiguration) --\n// --- New: Implement event listeners for rune events --\n// --- Modified: Update handleMessage to delegate to SacredRuneEngraver --\n\n\nimport { SystemContext, Rune } from '../../interfaces'; // Import types\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { SacredRuneEngraver } from '../core/rune-engrafting/SacredRuneEngraver'; // Access via context\n\n\nexport class RuneEngraftingAgent extends BaseAgent {\n    // private sacredRuneEngraver: SacredRuneEngraver; // Access via context\n\n\n    constructor(context: SystemContext) {\n        super('rune_engrafting', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Rune Engrafting Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[RuneEngraftingAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events from SacredRuneEngraver if needed (e.g., 'rune_registered', 'rune_uninstalled')\n            // This agent might need to react to these events, although the UI also listens directly.\n            // Example: this.context.eventBus.subscribe('rune_registered', (payload) => this.handleRuneRegistered(payload));\n\n        } catch (error) {\n            console.error('[RuneEngraftingAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Rune Engrafting Agent.\n     * Performs operations by delegating to the SacredRuneEngraver.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("]))[RuneEngraftingAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\n\n        const userId = this.context.currentUser?.id;\n        if (!userId) {\n             return { success: false, error: 'User not authenticated.' };\n        }\n\n        if (!this.context.sacredRuneEngraver) { // Check if SacredRuneEngraver is available\n             return { success: false, error: 'SacredRuneEngraver service is not available.' };\n        }\n\n        try {\n            let result: any;\n            switch (message.type) {\n                case 'register_rune':\n                    // Payload: Rune (including implementation reference)\n                    if (!message.payload?.id || !message.payload?.implementation) {\n                         throw new Error('Rune ID and implementation are required to register rune.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    await this.context.sacredRuneEngraver.registerRune(message.payload);\n                    result = { message: ";
Rune;
$;
{
    message.payload.name;
}
registered.(__makeTemplateObject([" };\n                    return { success: true, data: result };\n\n                case 'list_runes':\n                    // Payload: { typeFilter?: Rune['type'] }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.listRunes(message.payload?.typeFilter, userId); // Pass userId\n                    return { success: true, data: result };\n\n                case 'execute_rune_action':\n                    // Payload: { runeId: string, action: string, params?: any }\n                    if (!message.payload?.runeId || !message.payload?.action) {\n                         throw new Error('Rune ID and action are required to execute rune action.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.executeRuneAction(\n                        message.payload.runeId,\n                        message.payload.action,\n                        message.payload.params,\n                        userId // Pass userId\n                    );\n                    // executeRuneAction returns the result directly\n                    return { success: true, data: result };\n\n                case 'install_rune':\n                    // Payload: { publicRuneId: string }\n                    if (!message.payload?.publicRuneId) {\n                         throw new Error('Public Rune ID is required to install rune.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.installRune(message.payload.publicRuneId, userId); // Pass publicRuneId and userId\n                    // installRune returns the new user rune or null if already installed\n                    return { success: true, data: result };\n\n                case 'uninstall_rune':\n                    // Payload: { userRuneId: string }\n                    if (!message.payload?.userRuneId) {\n                         throw new Error('User Rune ID is required to uninstall rune.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.uninstallRune(message.payload.userRuneId, userId); // Pass userRuneId and userId\n                    if (!result) return { success: false, error: 'User Rune not found or not owned by user.' };\n                    return { success: true, data: { userRuneId: message.payload.userRuneId } }; // Return deleted ID\n\n                case 'update_rune_configuration':\n                    // Payload: { userRuneId: string, newConfig: any }\n                    if (!message.payload?.userRuneId || message.payload?.newConfig === undefined) {\n                         throw new Error('User Rune ID and new config are required to update configuration.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.updateRuneConfiguration(\n                        message.payload.userRuneId,\n                        message.payload.newConfig,\n                        userId // Pass userId\n                    );\n                    if (!result) return { success: false, error: 'User Rune not found or not owned by user.' };\n                    return { success: true, data: result };\n\n                case 'get_user_rune_capacity':\n                    // Payload: {}\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.getUserRuneCapacity(userId); // Pass userId\n                    if (!result) throw new Error('Failed to get user rune capacity.');\n                    return { success: true, data: result };\n\n\n                // TODO: Add cases for other Rune operations (e.g., get_rune_by_id, get_rune_manifest)\n\n                default:\n                    console.warn("], [" };\n                    return { success: true, data: result };\n\n                case 'list_runes':\n                    // Payload: { typeFilter?: Rune['type'] }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.listRunes(message.payload?.typeFilter, userId); // Pass userId\n                    return { success: true, data: result };\n\n                case 'execute_rune_action':\n                    // Payload: { runeId: string, action: string, params?: any }\n                    if (!message.payload?.runeId || !message.payload?.action) {\n                         throw new Error('Rune ID and action are required to execute rune action.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.executeRuneAction(\n                        message.payload.runeId,\n                        message.payload.action,\n                        message.payload.params,\n                        userId // Pass userId\n                    );\n                    // executeRuneAction returns the result directly\n                    return { success: true, data: result };\n\n                case 'install_rune':\n                    // Payload: { publicRuneId: string }\n                    if (!message.payload?.publicRuneId) {\n                         throw new Error('Public Rune ID is required to install rune.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.installRune(message.payload.publicRuneId, userId); // Pass publicRuneId and userId\n                    // installRune returns the new user rune or null if already installed\n                    return { success: true, data: result };\n\n                case 'uninstall_rune':\n                    // Payload: { userRuneId: string }\n                    if (!message.payload?.userRuneId) {\n                         throw new Error('User Rune ID is required to uninstall rune.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.uninstallRune(message.payload.userRuneId, userId); // Pass userRuneId and userId\n                    if (!result) return { success: false, error: 'User Rune not found or not owned by user.' };\n                    return { success: true, data: { userRuneId: message.payload.userRuneId } }; // Return deleted ID\n\n                case 'update_rune_configuration':\n                    // Payload: { userRuneId: string, newConfig: any }\n                    if (!message.payload?.userRuneId || message.payload?.newConfig === undefined) {\n                         throw new Error('User Rune ID and new config are required to update configuration.');\n                    }\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.updateRuneConfiguration(\n                        message.payload.userRuneId,\n                        message.payload.newConfig,\n                        userId // Pass userId\n                    );\n                    if (!result) return { success: false, error: 'User Rune not found or not owned by user.' };\n                    return { success: true, data: result };\n\n                case 'get_user_rune_capacity':\n                    // Payload: {}\n                    // Delegate to SacredRuneEngraver\n                    result = await this.context.sacredRuneEngraver.getUserRuneCapacity(userId); // Pass userId\n                    if (!result) throw new Error('Failed to get user rune capacity.');\n                    return { success: true, data: result };\n\n\n                // TODO: Add cases for other Rune operations (e.g., get_rune_by_id, get_rune_manifest)\n\n                default:\n                    console.warn("]))[RuneEngraftingAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");\n                    return { success: false, error: ";
Unknown;
message;
type;
for (RuneEngraftingAgent; ; )
    : $;
{
    message.type;
}
" };\n            }\n        } catch (error: any) {\n            console.error("[RuneEngraftingAgent];
Error;
handling;
message;
$;
{
    message.type;
}
", error);\n            return { success: false, error: error.message || 'An error occurred in RuneEngraftingAgent.' };\n        }\n    }\n\n    // TODO: Implement methods to send messages to other agents if needed\n}\n"(__makeTemplateObject([""], [""]));
