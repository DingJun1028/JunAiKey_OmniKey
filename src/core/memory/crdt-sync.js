var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/core/memory/crdt-sync.ts\n// \u6C38\u4E45\u8A18\u61B6\u4E2D\u5FC3 (Long-term Memory) - CRDT \u540C\u6B65\u6F14\u7B97\u6CD5 (Placeholder)\n// This file is a placeholder for CRDT implementation if needed for complex offline-first or multi-writer scenarios.\n// For basic Supabase Realtime sync, a full CRDT might not be necessary.\n// Part of the Bidirectional Sync Domain (\u96D9\u5411\u540C\u6B65\u9818\u57DF).\n// Design Principle: Supports MECE by defining clear rules for merging data changes.\n\ninterface CRDTEntry {  id: string;  timestamp: number; // Using timestamp as a simple version indicator for MVP  value: any;  // In a real CRDT, you'd use vector clocks or similar mechanisms  // vectorClock?: Record<string, number>;  // tombstone?: boolean; // For deletions}/** * Merges local and remote CRDT entries. * In this MVP placeholder, it's a simple merge based on timestamp (last write wins for same ID). * A real CRDT implementation would be more complex (e.g., LWW-element-set, PN-counter). */export const mergeCRDT = (local: CRDTEntry[], remote: CRDTEntry[]): CRDTEntry[] => {  console.log('Merging CRDT data (placeholder)...');  const mergedMap = new Map<string, CRDTEntry>();  // Add local entries  local.forEach(entry => mergedMap.set(entry.id, entry));  // Add or update with remote entries (last write wins based on timestamp)  remote.forEach(entry => {    const existing = mergedMap.get(entry.id);    if (!existing || entry.timestamp > existing.timestamp) {      mergedMap.set(entry.id, entry);    }    // TODO: Handle tombstones for deletions in a real CRDT  });  const mergedEntries = Array.from(mergedMap.values());  // Sort by timestamp (optional, but can help with deterministic processing)  mergedEntries.sort((a, b) => a.timestamp - b.timestamp);  console.log('Merge complete (placeholder). Total entries:', mergedEntries.length);  return mergedEntries;};// TODO: Implement actual CRDT logic (e.g., handling deletions, different CRDT types)// TODO: Integrate with sync mechanism (e.g., WebSocket, Supabase Realtime) (Part of Bidirectional Sync Domain)// TODO: Define how CRDT state is stored and retrieved (e.g., in local storage, IndexedDB, or a dedicated Supabase table)// TODO: This module is part of the Bidirectional Sync Domain (\u96D9\u5411\u540C\u6B65\u9818\u57DF).// Example Usage (for testing)// const localData: CRDTEntry[] = [//   { id: 'task-1', timestamp: 1678886400000, value: { text: 'Buy milk', completed: false } },//   { id: 'task-2', timestamp: 1678886460000, value: { text: 'Walk dog', completed: false } },// ];// const remoteData: CRDTEntry[] = [//   { id: 'task-1', timestamp: 1678886500000, value: { text: 'Buy milk', completed: true } }, // Updated//   { id: 'task-3', timestamp: 1678886520000, value: { text: 'Read book', completed: false } }, // New// ];// const result = mergeCRDT(localData, remoteData);// console.log(result);"], ["typescript\n// src/core/memory/crdt-sync.ts\n// \u6C38\u4E45\u8A18\u61B6\u4E2D\u5FC3 (Long-term Memory) - CRDT \u540C\u6B65\u6F14\u7B97\u6CD5 (Placeholder)\n// This file is a placeholder for CRDT implementation if needed for complex offline-first or multi-writer scenarios.\n// For basic Supabase Realtime sync, a full CRDT might not be necessary.\n// Part of the Bidirectional Sync Domain (\u96D9\u5411\u540C\u6B65\u9818\u57DF).\n// Design Principle: Supports MECE by defining clear rules for merging data changes.\n\ninterface CRDTEntry {\\\n  id: string;\\\n  timestamp: number; // Using timestamp as a simple version indicator for MVP\\\n  value: any;\\\n  // In a real CRDT, you'd use vector clocks or similar mechanisms\\\n  // vectorClock?: Record<string, number>;\\\n  // tombstone?: boolean; // For deletions\\\n}\\\n\\\n/**\\\n * Merges local and remote CRDT entries.\\\n * In this MVP placeholder, it's a simple merge based on timestamp (last write wins for same ID).\\\n * A real CRDT implementation would be more complex (e.g., LWW-element-set, PN-counter).\\\n */\\\nexport const mergeCRDT = (local: CRDTEntry[], remote: CRDTEntry[]): CRDTEntry[] => {\\\n  console.log('Merging CRDT data (placeholder)...');\\\n  const mergedMap = new Map<string, CRDTEntry>();\\\n\\\n  // Add local entries\\\n  local.forEach(entry => mergedMap.set(entry.id, entry));\\\n\\\n  // Add or update with remote entries (last write wins based on timestamp)\\\n  remote.forEach(entry => {\\\n    const existing = mergedMap.get(entry.id);\\\n    if (!existing || entry.timestamp > existing.timestamp) {\\\n      mergedMap.set(entry.id, entry);\\\n    }\\\n    // TODO: Handle tombstones for deletions in a real CRDT\\\n  });\\\n\\\n  const mergedEntries = Array.from(mergedMap.values());\\\n\\\n  // Sort by timestamp (optional, but can help with deterministic processing)\\\n  mergedEntries.sort((a, b) => a.timestamp - b.timestamp);\\\n\\\n  console.log('Merge complete (placeholder). Total entries:', mergedEntries.length);\\\n  return mergedEntries;\\\n};\\\n\\\n// TODO: Implement actual CRDT logic (e.g., handling deletions, different CRDT types)\\\n// TODO: Integrate with sync mechanism (e.g., WebSocket, Supabase Realtime) (Part of Bidirectional Sync Domain)\\\n// TODO: Define how CRDT state is stored and retrieved (e.g., in local storage, IndexedDB, or a dedicated Supabase table)\\\n// TODO: This module is part of the Bidirectional Sync Domain (\u96D9\u5411\u540C\u6B65\u9818\u57DF).\\\n\\\n// Example Usage (for testing)\\\n// const localData: CRDTEntry[] = [\\\n//   { id: 'task-1', timestamp: 1678886400000, value: { text: 'Buy milk', completed: false } },\\\n//   { id: 'task-2', timestamp: 1678886460000, value: { text: 'Walk dog', completed: false } },\\\n// ];\\\n// const remoteData: CRDTEntry[] = [\\\n//   { id: 'task-1', timestamp: 1678886500000, value: { text: 'Buy milk', completed: true } }, // Updated\\\n//   { id: 'task-3', timestamp: 1678886520000, value: { text: 'Read book', completed: false } }, // New\\\n// ];\\\n// const result = mergeCRDT(localData, remoteData);\\\n// console.log(result);\\\n"]))(__makeTemplateObject([""], [""]));
