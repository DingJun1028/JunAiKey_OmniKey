var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var _a, _b;
""(__makeTemplateObject(["typescript\n// src/agents/AnalyticsAgent.ts\n// \u5206\u6790\u4EE3\u7406 (Analytics Agent)\n// Handles operations related to analytics and KPIs.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates analytics logic.\n// --- Modified: Add operations for abilities (forge, get, update, delete, execute) --\n// --- New: Implement event listeners for triggering abilities --\n// --- Modified: Ensure findMatchingAbilities is called on relevant events --\n// --- Modified: Update EvolutionaryInsight interface and Supabase table with 'status' field --\n// --- Modified: Update getInsights to filter by status (default pending) --\n// --- Modified: Update handleInsightAction to set insight status to 'actioned' on success --\n// --- Modified: Update dismissInsight to set insight status to 'dismissed' --\n// --- Modified: Update runEvolutionCycle to set insight status to 'pending' and remove 'dismissed' --\n// --- Modified: Implement analyzeIncorrectFeedback to call WisdomSecretArt for correction suggestion --\n// --- Modified: Implement applying knowledge correction suggestions via KnowledgeAgent --\n// --- Modified: Update analyzeIncorrectFeedback to use requestAgent for KnowledgeAgent call --\n// --- Modified: Update handleMessage to delegate to AnalyticsService --\n// --- Modified: Update handleMessage to use requestAgent for SupabaseAgent calls --\n\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { AnalyticsService } from '../../modules/analytics/AnalyticsService'; // Access via context\n// import { SupabaseAgent } from './SupabaseAgent'; // Access via requestAgent\n\n\nexport class AnalyticsAgent extends BaseAgent {\n    // private analyticsService: AnalyticsService; // Access via context\n    // private supabaseAgent: SupabaseAgent; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        super('analytics', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Analytics Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[AnalyticsAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events (e.g., task_completed, rune_action_executed) to collect data in realtime\n            // This agent might listen to events and store raw data for later processing by AnalyticsService.\n            // Example: this.context.eventBus.subscribe('task_completed', (payload) => this.handleTaskCompleted(payload));\n\n        } catch (error) {\n            console.error('[AnalyticsAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Analytics Agent.\n     * Performs operations by delegating to the AnalyticsService.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\        console.log("], ["typescript\n// src/agents/AnalyticsAgent.ts\n// \\u5206\\u6790\\u4ee3\\u7406 (Analytics Agent)\n// Handles operations related to analytics and KPIs.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates analytics logic.\n// --- Modified: Add operations for abilities (forge, get, update, delete, execute) --\n// --- New: Implement event listeners for triggering abilities --\n// --- Modified: Ensure findMatchingAbilities is called on relevant events --\n// --- Modified: Update EvolutionaryInsight interface and Supabase table with 'status' field --\n// --- Modified: Update getInsights to filter by status (default pending) --\n// --- Modified: Update handleInsightAction to set insight status to 'actioned' on success --\n// --- Modified: Update dismissInsight to set insight status to 'dismissed' --\n// --- Modified: Update runEvolutionCycle to set insight status to 'pending' and remove 'dismissed' --\n// --- Modified: Implement analyzeIncorrectFeedback to call WisdomSecretArt for correction suggestion --\n// --- Modified: Implement applying knowledge correction suggestions via KnowledgeAgent --\n// --- Modified: Update analyzeIncorrectFeedback to use requestAgent for KnowledgeAgent call --\n// --- Modified: Update handleMessage to delegate to AnalyticsService --\n// --- Modified: Update handleMessage to use requestAgent for SupabaseAgent calls --\n\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { AnalyticsService } from '../../modules/analytics/AnalyticsService'; // Access via context\n// import { SupabaseAgent } from './SupabaseAgent'; // Access via requestAgent\n\n\nexport class AnalyticsAgent extends BaseAgent {\n    // private analyticsService: AnalyticsService; // Access via context\n    // private supabaseAgent: SupabaseAgent; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        super('analytics', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Analytics Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[AnalyticsAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events (e.g., task_completed, rune_action_executed) to collect data in realtime\n            // This agent might listen to events and store raw data for later processing by AnalyticsService.\n            // Example: this.context.eventBus.subscribe('task_completed', (payload) => this.handleTaskCompleted(payload));\n\n        } catch (error) {\n            console.error('[AnalyticsAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Analytics Agent.\n     * Performs operations by delegating to the AnalyticsService.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\\\\\\n        console.log("]))[AnalyticsAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\\\\\n        const userId = this.context.currentUser?.id;\\        if (!userId) {\\             return { success: false, error: 'User not authenticated.' };\\        }\\\n\\\n        try {\\            let result: any;\\            switch (message.type) {\\                case 'calculate_kpis':\\                    // Payload: { timeframe?: 'day' | 'week' | 'month' | 'all' }\\                    // Delegate to AnalyticsService\\                    result = await this.context.analyticsService?.calculateKPIs(message.payload?.timeframe, userId);\\                    if (!result) throw new Error('Failed to calculate KPIs.');\\                    return { success: true, data: result };\\\\\n                case 'get_data_for_evolution':\\                    // Payload: { timeframe?: 'day' | 'week' | 'month' | 'all' }\\                    // Delegate to AnalyticsService\\                    result = await this.context.analyticsService?.getDataForEvolution(userId, message.payload?.timeframe);\\                    if (!result) throw new Error('Failed to get data for evolution.');\\                    return { success: true, data: result };\\\\\n                case 'get_recent_logs':\\                    // Payload: { limit?: number, level?: 'info' | 'warn' | 'error' | 'debug' }\\                    // Delegate to LoggingService via SupabaseAgent (assuming logs are in DB)\\                    if (!this.context.agentFactory?.getAgent('supabase')) {\\                         throw new Error('SupabaseAgent not available to fetch logs.');\\                    }\\                    console.log('[AnalyticsAgent] Requesting recent logs from SupabaseAgent...');\\                    // Use query_records message type for SupabaseAgent\\                    const logsResponse = await this.requestAgent(\\\n                        'supabase', // Target the SupabaseAgent\\\n                        'query_records', // Message type for SupabaseAgent\\                        {\\\n                            table: 'system_events', // Assuming logs are stored in system_events\\\n                            select: '*',\\\n                            query: { user_id: userId }, // Filter by user ID\\\n                            order: { column: 'timestamp', ascending: false },\\\n                            limit: message.payload?.limit || 100,\\                        },\\                        10000 // Timeout\\                    );\\\\\n                    if (!logsResponse.success || !Array.isArray(logsResponse.data)) {\\                         throw new Error(logsResponse.error || 'SupabaseAgent failed to fetch logs.');\\                    }\\                    // Filter by severity level if requested (client-side for MVP)\\                    const filteredLogs = message.payload?.level\\                        ? logsResponse.data.filter((log: any) => log.severity === message.payload.level)\\                        : logsResponse.data;\\\\\n                    result = filteredLogs;\\                    return { success: true, data: result };\\\\\n                case 'get_user_activity_summary':\\                    // Payload: { timeframe?: 'day' | 'week' | 'month' | 'all' }\\                    // Delegate to AnalyticsService (or implement summary logic here)\\                    console.warn('[AnalyticsAgent] Simulating get_user_activity_summary.');\\                    await new Promise(resolve => setTimeout(resolve, 500));\\                    result = { message: 'Simulated user activity summary.', timeframe: message.payload?.timeframe };\\                    return { success: true, data: result };\\\\\n                case 'get_reports':\\                    // Payload: { type: string, options?: any }\\                    // Delegate to AnalyticsService (or implement report generation logic here)\\                    console.warn("[AnalyticsAgent];
Simulating;
get_reports;
for (type; ; )
    : $;
{
    (_a = message.payload) === null || _a === void 0 ? void 0 : _a.type;
}
");\\                    await new Promise(resolve => setTimeout(resolve, 1000));\\                    result = { message: ";
Simulated;
report;
generated;
for (type; ; )
    : $;
{
    (_b = message.payload) === null || _b === void 0 ? void 0 : _b.type;
}
", reportType: message.payload?.type };\\                    return { success: true, data: result };\\\\\n                // TODO: Add cases for other Analytics operations (e.g., get_user_activity_summary)\\\\\n                default:\\                    console.warn("[AnalyticsAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");\\                    return { success: false, error: ";
Unknown;
message;
type;
for (AnalyticsAgent; ; )
    : $;
{
    message.type;
}
" };\\            }\\\n        } catch (error: any) {\\            console.error("[AnalyticsAgent];
Error;
handling;
message;
$;
{
    message.type;
}
", error);\\            return { success: false, error: error.message || 'An error occurred in AnalyticsAgent.' };\\        }\\\n    }\\\n\\\n    // TODO: Implement methods to send messages to other agents if needed\\}\\\n"(__makeTemplateObject([""], [""]));
