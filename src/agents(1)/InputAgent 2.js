var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/InputAgent.ts\n// \u8F38\u5165\u4EE3\u7406 (Input Agent)\n// Acts as the primary entry point for user input (text, voice, multimodal).\n// Orchestrates the initial steps of the Six Styles: Observe, Decide, and potentially Trigger/Act.\n// Design Principle: Receives raw input and initiates the processing pipeline.\n// --- Modified: Add multimodal input handling (image, audio, file) --\n// --- Modified: Refactor to use MessageBus for communication with other agents --\n// --- Modified: Implement correlationId logic for responses --\n// --- Modified: Update process_user_input to send analyze_intent message --\n// --- New: Add handler for execute_action_intent message --\n// --- Modified: Update simulate_visual_reading to call WisdomSecretArt and generate suggestion --\n// --- New: Add handler for handle_url_scheme message --\n// --- New: Add handlers for read_url and analyze_file_content actions --\n// --- Modified: Implement RAG flow for answer_via_ai action --\n// --- Modified: Update analyze_input_for_suggestions to use requestAgent --\n// --- Modified: Update process_user_input to use requestAgent for DecisionAgent call --\n// --- Modified: Include relevantKnowledge in the response data for 'answer_via_ai' action --\n// --- Modified: Ensure consistent error handling and logging --\n\n\nimport { SystemContext, ActionIntent, KnowledgeRecord } from '../../interfaces'; // Import SystemContext and ActionIntent\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services/agents this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { DecisionAgent } from './DecisionAgent'; // Access via requestAgent\n// import { WisdomSecretArt } from '../core/wisdom/WisdomSecretArt'; // Access via requestAgent\n// import { SelfNavigationEngine } from '../core/self-navigation/SelfNavigationEngine'; // Access via requestAgent\n// import { RuneEngraftingAgent } from './RuneEngraftingAgent'; // Access via requestAgent\n// import { KnowledgeAgent } from './KnowledgeAgent'; // Access via requestAgent\n// import { SyncAgent } from './SyncAgent'; // Access via requestAgent\n// import { NotificationAgent } from './NotificationAgent'; // Access via requestAgent\n// import { GoalManagementAgent } from './GoalManagementAgent'; // Access via requestAgent\n// import { DeviceAgent } from './DeviceAgent'; // Access via requestAgent\n// import { RAGRetriever } from '../rag/retriever'; // Access via requestAgent\n\n\nexport class InputAgent extends BaseAgent { // Extend BaseAgent\n    // References to other agents (obtained from AgentFactory)\n    // private decisionAgent: DecisionAgent | null = null; // Access via requestAgent\n    // private selfNavigationAgent: SelfNavigationEngine | null = null; // Access via requestAgent\n    // private runeEngraftingAgent: RuneEngraftingAgent | null = null; // Access via requestAgent\n    // private knowledgeAgent: KnowledgeAgent | null = null; // Access via requestAgent\n    // private syncAgent = this.context.agentFactory?.getAgent('sync') || null; // Access via requestAgent\n    // private notificationAgent = this.context.agentFactory?.getAgent('notification') || null; // Access via requestAgent\n    // private goalManagementAgent = this.context.agentFactory?.getAgent('goal_management') || null; // Access via requestAgent\n    // private deviceAgent = this.context.agentFactory?.getAgent('device') || null; // Access via requestAgent\n    // private ragRetriever: RAGRetriever | null = null; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        // --- Modified: Call super constructor with agent name ---\n        super('input', context); // Call BaseAgent constructor with agent name 'input'\n        // --- End Modified ---\n        // Services/Runes are accessed via requestAgent or context\n    }\n\n    /**\n     * Initializes the Input Agent by getting references to other agents.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Get references to other agents from the factory\n            // This is how agents discover and communicate with each other\n            // this.decisionAgent = this.context.agentFactory?.getAgent('decision') || null;\n            // this.selfNavigationAgent = this.context.selfNavigationEngine; // Access via context\n            // this.runeEngraftingAgent = this.context.sacredRuneEngraver; // Access via context\n            // this.knowledgeAgent = this.context.agentFactory?.getAgent('knowledge') || null;\n            // this.syncAgent = this.context.agentFactory?.getAgent('sync') || null;\n            // this.notificationAgent = this.context.agentFactory?.getAgent('notification') || null;\n            // this.goalManagementAgent = this.context.agentFactory?.getAgent('goal_management') || null;\n            // this.deviceAgent = this.context.agentFactory?.getAgent('device') || null;\n            // this.ragRetriever = this.context.agentFactory?.getAgent('rag_retriever') || null;\n\n            console.log('[InputAgent] Other agents obtained.');\n        } catch (error) {\n            console.error('[InputAgent] Failed to get other agents during init:', error);\n            // Handle error - maybe log or set agent status to unhealthy\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Input Agent.\n     * This is the main processing logic for incoming user input or actions triggered by UI/other agents.\n     * @param message The message to handle. Expected type: 'process_user_input' or 'execute_action_intent'.\n     * @returns Promise<AgentResponse> The response containing the result of the processing.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("], ["typescript\n// src/agents/InputAgent.ts\n// \\u8f38\\u5165\\u4ee3\\u7406 (Input Agent)\n// Acts as the primary entry point for user input (text, voice, multimodal).\\n// Orchestrates the initial steps of the Six Styles: Observe, Decide, and potentially Trigger/Act.\\n// Design Principle: Receives raw input and initiates the processing pipeline.\\n// --- Modified: Add multimodal input handling (image, audio, file) --\\n// --- Modified: Refactor to use MessageBus for communication with other agents --\\n// --- Modified: Implement correlationId logic for responses --\\n// --- Modified: Update process_user_input to send analyze_intent message --\\n// --- New: Add handler for execute_action_intent message --\\n// --- Modified: Update simulate_visual_reading to call WisdomSecretArt and generate suggestion --\\n// --- New: Add handler for handle_url_scheme message --\\n// --- New: Add handlers for read_url and analyze_file_content actions --\\n// --- Modified: Implement RAG flow for answer_via_ai action --\\n// --- Modified: Update analyze_input_for_suggestions to use requestAgent --\\n// --- Modified: Update process_user_input to use requestAgent for DecisionAgent call --\\n// --- Modified: Include relevantKnowledge in the response data for 'answer_via_ai' action --\\n// --- Modified: Ensure consistent error handling and logging --\\n\\n\\nimport { SystemContext, ActionIntent, KnowledgeRecord } from '../../interfaces'; // Import SystemContext and ActionIntent\\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\\n\\n// Import existing services/agents this agent will interact with (temporarily)\\n// In a full refactor, the logic from these services would move INTO this agent.\\n// For MVP, this agent acts as a proxy to the existing services.\\n// import { DecisionAgent } from './DecisionAgent'; // Access via requestAgent\\n// import { WisdomSecretArt } from '../core/wisdom/WisdomSecretArt'; // Access via requestAgent\\n// import { SelfNavigationEngine } from '../core/self-navigation/SelfNavigationEngine'; // Access via requestAgent\\n// import { RuneEngraftingAgent } from './RuneEngraftingAgent'; // Access via requestAgent\\n// import { KnowledgeAgent } from './KnowledgeAgent'; // Access via requestAgent\\n// import { SyncAgent } from './SyncAgent'; // Access via requestAgent\\n// import { NotificationAgent } from './NotificationAgent'; // Access via requestAgent\\n// import { GoalManagementAgent } from './GoalManagementAgent'; // Access via requestAgent\\n// import { DeviceAgent } from './DeviceAgent'; // Access via requestAgent\\n// import { RAGRetriever } from '../rag/retriever'; // Access via requestAgent\\n\\n\\nexport class InputAgent extends BaseAgent { // Extend BaseAgent\\n    // References to other agents (obtained from AgentFactory)\\n    // private decisionAgent: DecisionAgent | null = null; // Access via requestAgent\\n    // private selfNavigationAgent: SelfNavigationEngine | null = null; // Access via requestAgent\\n    // private runeEngraftingAgent: RuneEngraftingAgent | null = null; // Access via requestAgent\\n    // private knowledgeAgent: KnowledgeAgent | null = null; // Access via requestAgent\\n    // private syncAgent = this.context.agentFactory?.getAgent('sync') || null; // Access via requestAgent\\n    // private notificationAgent = this.context.agentFactory?.getAgent('notification') || null; // Access via requestAgent\\n    // private goalManagementAgent = this.context.agentFactory?.getAgent('goal_management') || null; // Access via requestAgent\\n    // private deviceAgent = this.context.agentFactory?.getAgent('device') || null; // Access via requestAgent\\n    // private ragRetriever: RAGRetriever | null = null; // Access via requestAgent\\n\\n\\n    constructor(context: SystemContext) {\\n        // --- Modified: Call super constructor with agent name ---\\n        super('input', context); // Call BaseAgent constructor with agent name 'input'\\n        // --- End Modified ---\\n        // Services/Runes are accessed via requestAgent or context\\n    }\\n\\n    /**\\n     * Initializes the Input Agent by getting references to other agents.\\n     */\\n    init(): void {\\n        super.init(); // Call base init\\n        try {\\n            // Get references to other agents from the factory\\n            // This is how agents discover and communicate with each other\\n            // this.decisionAgent = this.context.agentFactory?.getAgent('decision') || null;\\n            // this.selfNavigationAgent = this.context.selfNavigationEngine; // Access via context\\n            // this.runeEngraftingAgent = this.context.sacredRuneEngraver; // Access via context\\n            // this.knowledgeAgent = this.context.agentFactory?.getAgent('knowledge') || null;\\n            // this.syncAgent = this.context.agentFactory?.getAgent('sync') || null;\\n            // this.notificationAgent = this.context.agentFactory?.getAgent('notification') || null;\\n            // this.goalManagementAgent = this.context.agentFactory?.getAgent('goal_management') || null;\\n            // this.deviceAgent = this.context.agentFactory?.getAgent('device') || null;\\n            // this.ragRetriever = this.context.agentFactory?.getAgent('rag_retriever') || null;\\n\\n            console.log('[InputAgent] Other agents obtained.');\\n        } catch (error) {\\n            console.error('[InputAgent] Failed to get other agents during init:', error);\\n            // Handle error - maybe log or set agent status to unhealthy\\n        }\\n    }\\n\\n\\n    /**\\n     * Handles messages directed to the Input Agent.\\n     * This is the main processing logic for incoming user input or actions triggered by UI/other agents.\\n     * @param message The message to handle. Expected type: 'process_user_input' or 'execute_action_intent'.\\n     * @returns Promise<AgentResponse> The response containing the result of the processing.\\n     */\\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\n        console.log("]))[InputAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\n        this.context.loggingService?.logInfo(";
InputAgent;
received;
message: $;
{
    message.type;
}
", { messageType: message.type, correlationId: message.correlationId, sender: message.sender, payload: message.payload });\n\n\n        const userId = this.context.currentUser?.id;\n        if (!userId) {\n             // Return error response if user is not authenticated\n             return { success: false, error: 'User not authenticated.' };\n        }\n\n        try {\n            let result: any;\n            switch (message.type) {\n                case 'process_user_input':\n                    // This message type is for raw user input (text, multimodal) from UI/CLI.\n                    // Orchestrates the initial Observe -> Decide steps.\n                    // Payload: { text?: string, imageUrl?: string, audioUrl?: string, fileUrl?: string, fileMetadata?: any, context?: any }\n                    const { text, imageUrl, audioUrl, fileUrl, fileMetadata, context } = message.payload;\n\n                    if (!text && !imageUrl && !audioUrl && !fileUrl) {\n                         // Return error response if input is empty\n                         return { success: false, error: 'Input text or multimodal content is required.' };\n                    }\n\n                    console.log('[InputAgent] Processing user input...');\n\n                    // --- 1. Observe (Implicit via Logging/Analytics) ---\n                    // User action is already recorded by the UI/CLI before sending the message.\n                    // LoggingService and AnalyticsService passively observe system events and actions.\n\n                    // --- 2. Decide (Delegate to DecisionAgent) ---\n                    // Send a message to the DecisionAgent to analyze the intent.\n                    // Use requestAgent to send the message and wait for the response.\n                    console.log('[InputAgent] Requesting intent analysis from DecisionAgent...');\n                    // --- Modified: Use requestAgent for DecisionAgent call ---\n                    const decisionResponse = await this.requestAgent(\n                        'decision', // Target the DecisionAgent\n                        'analyze_intent', // Message type for DecisionAgent\n                        { text, imageUrl, audioUrl, fileUrl, fileMetadata, context }, // Pass input and context\n                        15000 // Timeout for intent analysis (can be long if using LLM)\n                    );\n                    // --- End Modified ---\n\n                    if (!decisionResponse.success || !decisionResponse.data) {\n                         // If DecisionAgent fails or returns no decision, propagate the error\n                         const errorMsg = decisionResponse.error || 'DecisionAgent failed to determine intent.';\n                         console.error('[InputAgent] DecisionAgent failed:', errorMsg);\n                         this.context.loggingService?.logError('InputAgent DecisionAgent failed.', { userId, error: errorMsg, correlationId: message.correlationId });\n                         return { success: false, error: errorMsg }; // Return error response\n                    }\n\n                    const decidedAction: ActionIntent = decisionResponse.data; // The decided ActionIntent\n\n                    console.log('[InputAgent] Received decided action from DecisionAgent:', decidedAction);\n\n                    // --- 3. Act / Trigger (Delegate based on decided action) ---\n                    // Now that we have the decided action, delegate it to the appropriate agent.\n                    // This is the core of the 'Act' or 'Trigger' step.\n                    // We will send a new message with type 'execute_action_intent' to the InputAgent itself.\n                    // This allows the InputAgent to handle the execution delegation in a separate message handler,\n                    // making the process_user_input handler cleaner and focused on Observe/Decide.\n                    // It also allows other agents/systems to trigger actions directly using 'execute_action_intent'.\n\n                    console.log("[InputAgent];
Delegating;
execution;
of;
decided;
action: $;
{
    decidedAction.action;
}
");\n                    // Send the decided action as a new message to the InputAgent's own queue\n                    // Use a new correlationId for the execution phase, linked to the original\n                    const executionCorrelationId = ";
exec - $;
{
    decidedAction.action;
}
-$;
{
    message.correlationId || 'N/A';
}
";\n                    this.sendMessage({\n                        type: 'execute_action_intent', // Message type to execute a pre-defined action intent\n                        payload: { decision: decidedAction, context: { ...context, originalCorrelationId: message.correlationId, originalInput: text, originalMultimodal: { imageUrl, audioUrl, fileUrl, fileMetadata } } }, // Pass the ActionIntent and context, including original input/multimodal\n                        recipient: this.agentName, // Send back to InputAgent for execution delegation\n                        correlationId: executionCorrelationId, // New correlation ID for execution\n                        sender: this.agentName, // Sender is InputAgent\n                    });\n\n                    // The response to the original 'process_user_input' message can indicate that processing is ongoing\n                    // and the execution result will be provided via a subsequent message (linked by correlationId).\n                    // For MVP, let's return a success response indicating the action was delegated.\n                    // The actual result will come later via the agent_response for the executionCorrelationId.\n                    const successResponse: AgentResponse = { success: true, data: { message: ";
Action;
'${decidedAction.action}';
delegated;
for (execution.(__makeTemplateObject([", decidedAction: decidedAction } }; // Include decidedAction in response\n                    // Send response back if the original message had a correlationId\n                    if (message.correlationId) {\n                        this.sendResponse(message, successResponse);\n                    }\n                    return successResponse; // Return for internal processing\n\n\n                case 'execute_action_intent':\n                    // This message type is received when an ActionIntent needs to be executed.\n                    // It can come from process_user_input or other agents/systems.\n                    // Payload: { decision: ActionIntent, context?: any }\n                    const actionToExecute: ActionIntent = message.payload?.decision;\n                    const executionContext = message.payload?.context;\n\n                    if (!actionToExecute?.action) {\n                         // Return error response if ActionIntent is missing\n                         return { success: false, error: 'ActionIntent is required for execute_action_intent.' };\n                    }\n\n                    console.log("], [", decidedAction: decidedAction } }; // Include decidedAction in response\\n                    // Send response back if the original message had a correlationId\\n                    if (message.correlationId) {\\n                        this.sendResponse(message, successResponse);\\n                    }\\n                    return successResponse; // Return for internal processing\\n\\n\\n                case 'execute_action_intent':\\n                    // This message type is received when an ActionIntent needs to be executed.\\n                    // It can come from process_user_input or other agents/systems.\\n                    // Payload: { decision: ActionIntent, context?: any }\\n                    const actionToExecute: ActionIntent = message.payload?.decision;\\n                    const executionContext = message.payload?.context;\\n\\n                    if (!actionToExecute?.action) {\\n                         // Return error response if ActionIntent is missing\\n                         return { success: false, error: 'ActionIntent is required for execute_action_intent.' };\\n                    }\\n\\n                    console.log("]))[InputAgent]; Executing; ActionIntent)
    : $;
{
    actionToExecute.action;
}
(function (Confidence, _a) {
    var actionToExecute = _a.actionToExecute, confidence = _a.confidence;
    return ;
});
");\n                    this.context.loggingService?.logInfo(";
InputAgent;
executing;
ActionIntent: $;
{
    actionToExecute.action;
}
", { userId, action: actionToExecute, context: executionContext, correlationId: message.correlationId });\n\n\n                    let executionResult: any = null;\n                    let executionError: string | undefined = undefined;\n                    let executionSuccess = false;\n                    let targetAgent: string | undefined = undefined; // Agent responsible for executing this action type\n\n\n                    try {\n                        // Delegate the execution to the appropriate agent based on the action type.\n                        // Use requestAgent to send the message and wait for the result.\n                        // The message type sent to the target agent is typically the action name itself.\n                        // The payload sent to the target agent is the action's parameters.\n\n                        switch (actionToExecute.action) {\n                            case 'create_task': targetAgent = 'self_navigation'; break;\n                            case 'execute_rune': targetAgent = 'rune_engrafting'; break;\n                            case 'search_knowledge': targetAgent = 'knowledge'; break;\n                            case 'sync_mobile_git': targetAgent = 'sync'; break;\n                            case 'present_suggestion': targetAgent = 'ui'; break; // UI Agent handles presenting suggestions\n                            case 'create_agentic_flow': targetAgent = 'self_navigation'; break;\n                            case 'update_goal_progress': targetAgent = 'goal_management'; break;\n                            case 'synthesize_knowledge': targetAgent = 'knowledge'; break;\n                            case 'simulate_visual_reading': targetAgent = 'device'; break; // Device Agent handles device interactions\n                            case 'analyze_log_entry': targetAgent = 'evolution'; break; // Evolution Agent handles log analysis\n                            case 'read_url': targetAgent = 'device'; break; // Device Agent handles web interactions (via WebRune)\n                            case 'analyze_file_content': targetAgent = 'device'; break; // Device Agent handles file analysis\n                            case 'create_calendar_event': targetAgent = 'calendar'; break; // Calendar Agent handles calendar events\n                            case 'handle_url_scheme': targetAgent = 'device'; break; // Device Agent handles incoming URL schemes\n                            case 'interact_with_working_copy': targetAgent = 'device'; break; // Device Agent handles Working Copy interactions\n\n\n                            case 'answer_via_ai':\n                                // This action means the AI should generate a natural language response.\n                                // --- Modified: Implement RAG flow ---\n                                console.log('[InputAgent] Action is answer_via_ai. Initiating RAG flow...');\n                                if (!this.context.agentFactory?.getAgent('rag_retriever') || !this.context.agentFactory?.getAgent('wisdom')) {\n                                     throw new Error('RAGRetriever or WisdomAgent not available for RAG.');\n                                }\n\n                                // 1. Retrieve relevant knowledge based on the query (original input) and context\n                                const query = actionToExecute.parameters?.question || executionContext?.originalInput || '';\n                                const retrievalContext = executionContext?.context; // Pass original context to retrieval\n                                console.log("[InputAgent];
Retrieving;
relevant;
knowledge;
for (query; ; )
    : ;
"${query}\\\" with context:`, retrievalContext);\n                                const retrievalResponse = await this.requestAgent(\n                                    'rag_retriever', // Target the RAGRetriever Agent\n                                    'retrieve_relevant_data', // Message type for RAGRetriever\n                                    { query: query, options: { useSemanticSearch: true } }, // Pass query and options (semantic search)\n                                    15000 // Timeout for retrieval\n                                );\n\n                                let relevantKnowledge = retrievalResponse.data || [];\n                                if (!retrievalResponse.success || !Array.isArray(retrievalResponse.data)) {\n                                     console.warn('[InputAgent] RAGRetriever failed or returned no data. Proceeding with generation without context.');\n                                     this.context.loggingService?.logWarning('InputAgent RAGRetriever failed or returned no data.', { userId, query, error: retrievalResponse.error, correlationId: message.correlationId });\n                                     // Proceed with generation but pass an empty array for relevantKnowledge\n                                     relevantKnowledge = []; // Ensure it's an empty array on failure\n                                }\n\n\n                                // 2. Generate answer using the query and retrieved knowledge\n                                console.log('[InputAgent] Generating answer with context via WisdomAgent...');\n                                const generationResponse = await this.requestAgent(\n                                    'wisdom', // Target the WisdomAgent\n                                    'generate_answer_with_context', // Message type for WisdomAgent\n                                    { query: query, relevantKnowledge: relevantKnowledge, context: executionContext }, // Pass query, retrieved knowledge, and context\n                                    30000 // Timeout for LLM generation\n                                );\n\n                                if (!generationResponse.success || typeof generationResponse.data !== 'string') {\n                                     throw new Error(generationResponse.error || 'WisdomAgent failed to generate answer.');\n                                }\n                                // --- Modified: Include relevantKnowledge in the result data ---\n                                executionResult = { answer: generationResponse.data, relevantKnowledge: relevantKnowledge }; // Wrap the answer and include retrieved knowledge\n                                // --- End Modified ---\n                                executionSuccess = true; // Assume generation itself is successful if no error thrown\n                                // --- End Modified ---\n                                break;\n\n                            default:\n                                console.warn(`[InputAgent] Unknown action type for execution: ${actionToExecute.action}.`);\n                                executionError = `Unknown action type: ${actionToExecute.action}`;\n                                executionSuccess = false;\n                                break;\n                        }\n\n                        // If a target agent was determined and it's not 'answer_via_ai' (handled above)\n                        if (targetAgent && actionToExecute.action !== 'answer_via_ai') {\n                             // Send the action type and parameters as a message to the target agent\n                             // Use requestAgent to send the message and wait for the response\n                             const agentResponse = await this.requestAgent(\n                                 targetAgent, // Recipient agent name\n                                 actionToExecute.action, // Message type for the execution agent (the action name itself)\n                                 actionToExecute.parameters, // Payload for the execution agent (action parameters)\n                                 actionToExecute.action === 'execute_rune_action' ? 60000 : 30000 // Longer timeout for rune execution\n                             );\n                             executionResult = agentResponse.data; // Store the data from the response\n                             executionError = agentResponse.error; // Get error message from the response\n                             executionSuccess = agentResponse.success; // Get success status from the response\n                        }\n\n\n                    } catch (executionErr: any) {\n                        console.error(`[InputAgent] Error executing ActionIntent ${actionToExecute.action} (Correlation ID: ${message.correlationId || 'N/A'}):`, executionErr);\n                        this.context.loggingService?.logError(`InputAgent error executing ActionIntent: ${actionToExecute.action}`, { userId, action: actionToExecute, context: executionContext, error: executionErr.message, correlationId: message.correlationId });\n                        executionError = executionErr.message;\n                        executionSuccess = false;\n                    }\n\n                    // --- 4. Record Action Execution Outcome (Leverages Six Styles: Observe) ---\n                    // Record the outcome of the executed action (success or failure).\n                    // This should be done asynchronously.\n                    const outcomeActionType = executionSuccess ? `system:action:executed:${actionToExecute.action}` : `system:action:failed:${actionToExecute.action}`;\n                    this.context.authorityForgingEngine?.recordAction({\n                        type: outcomeActionType,\n                        details: {\n                            originalDecision: actionToExecute,\n                            result: executionResult,\n                            error: executionError,\n                        },\n                        context: {\n                            platform: executionContext?.platform || 'system',\n                            source: executionContext?.source || 'input_agent',\n                            userId: userId,\n                            originalInput: executionContext?.originalInput,\n                            originalMultimodal: executionContext?.originalMultimodal, // Include original multimodal context\n                            correlationId: message.correlationId, // Include correlationId\n                        },\n                        user_id: userId,\n                    }).catch(err => console.error('Failed to record action outcome:', err));\n\n\n                    // --- 5. Precipitate / Record Conversation Turn (Leverages Long-term Memory) ---\n                    // Save the original input and the final result/response as a knowledge record.\n                    // This is part of the \"Precipitate\" step for development logs/chat history.\n                    // This should be done asynchronously.\n                    if (this.context.knowledgeSync) {\n                         const conversationRecord: Omit<KnowledgeRecord, 'id' | 'timestamp'> = {\n                             question: executionContext?.originalInput || `Action: ${actionToExecute.action}`, // Use original input or action type as question\n                             answer: executionSuccess ? (executionResult?.message || executionResult?.answer || JSON.stringify(executionResult)) : (executionError || 'Action failed.'), // Use result message, generated answer, or error as answer\n                             user_id: userId,\n                             source: 'dev-conversation', // Mark as conversation history\n                             tags: ['chat', actionToExecute.action, executionSuccess ? 'success' : 'failed'], // Tag with chat, action type, and outcome\n                             dev_log_details: {\n                                 type: 'conversation-turn',\n                                 conversation_id: executionContext?.conversation_id || 'default-web-chat', // Use context conversation ID or a default\n                                 correlationId: message.correlationId, // Include correlationId\n                                 // turn_number: TODO: Implement turn numbering\n                                 originalDecision: actionToExecute, // Store the original decided action\n                                 executionOutcome: {\n                                     success: executionSuccess,\n                                     result: executionResult,\n                                     error: executionError,\n                                 },\n                                 linked_artifacts: [], // TODO: Link to generated artifacts if any (e.g., created task ID, created ability ID)\n                             },\n                             // --- New: Include multimodal content URLs if present in original context ---\n                             image_url: executionContext?.originalMultimodal?.imageUrl,\n                             audio_url: executionContext?.originalMultimodal?.audioUrl,\n                             file_url: executionContext?.originalMultimodal?.fileUrl,\n                             file_metadata: executionContext?.originalMultimodal?.fileMetadata,\n                             // --- End New ---\n                         };\n                         // Use KnowledgeSync to save the record\n                         this.context.knowledgeSync.saveKnowledge(\n                             conversationRecord.question,\n                             conversationRecord.answer,\n                             userId,\n                             conversationRecord.source,\n                             conversationRecord.dev_log_details,\n                             false, // Not starred by default\n                             conversationRecord.tags // Include tags\n                         ).catch(kbError => console.error('Failed to save conversation turn to KB:', kbError));\n                    } else {\n                         console.warn('[InputAgent] KnowledgeSync not available to save conversation turn.');\n                    }\n\n                    // --- 6. Return Response ---\n                    // Return a response indicating the outcome of the execution.\n                    // This response is sent back via the MessageBus to the original sender (e.g., UI).\n                    const finalResponse: AgentResponse = {\n                        success: executionSuccess,\n                        data: executionResult, // This now includes relevantKnowledge for 'answer_via_ai'\n                        error: executionError,\n                    };\n                    // Send response back if the original message had a correlationId\n                    if (message.correlationId) {\n                        this.sendResponse(message, finalResponse);\n                    }\n                    return finalResponse; // Also return for internal processing\n\n\n                case 'handle_url_scheme':\n                    // This message type is received from the DeviceAgent when a URL Scheme is activated.\n                    // Payload: { url: string }\n                    const { url } = message.payload;\n                    if (!url) {\n                         // Return error response if URL is missing\n                         return { success: false, error: 'URL is required for handle_url_scheme.' };\n                    }\n                    console.log(`[InputAgent] Handling incoming URL Scheme: ${url}`);\n                    this.context.loggingService?.logInfo(`InputAgent handling URL Scheme: ${url}`, { userId, url, correlationId: message.correlationId });\n\n                    // --- Simulate parsing the URL Scheme and deciding on an action ---\n                    // This is a simplified parser. A real parser would handle different schemes and parameters.\n                    // Example schemes:\n                    // - junai://action?type=create_task&params={...}\n                    // - junai://share?data={...}\n                    // - working-copy://x-callback-url/read?repo=...&path=...&x-success=...\n                    // - myapp://x-callback-url/workingcopy-callback?status=success&... (Callback from Working Copy)\n\n                    let decidedActionFromUrl: ActionIntent | null = null;\n                    let processingMessage = `Processing incoming URL Scheme: ${url}`;\\\n\n                    try {\\\n                        const parsedUrl = new URL(url);\\\n                        const scheme = parsedUrl.protocol.replace(':', ''); // e.g., 'junai', 'working-copy'\\\n                        const host = parsedUrl.host; // e.g., 'action', 'share', 'x-callback-url'\\\n                        const pathSegments = parsedUrl.pathname.split('/').filter(segment => segment); // e.g., ['read']\\\n\\\n                        console.log(`[InputAgent] Parsed URL Scheme: scheme=${scheme}, host=${host}, path=${pathSegments.join('/')}`);\\\n\\\n                        if (scheme === 'junai') {\\\n                            // Handle internal Jun.Ai.Key URL schemes\\\n                            if (host === 'action' && pathSegments.length === 0) {\\\n                                // Example: junai://action?type=create_task&params={...}\\\n                                const actionType = parsedUrl.searchParams.get('type');\\\n                                const paramsJson = parsedUrl.searchParams.get('params');\\\n                                let params: any = {};\\\n                                if (paramsJson) {\\\n                                    try {\\\n                                        params = JSON.parse(paramsJson);\\\n                                    } catch (parseError) {\\\n                                        console.error('[InputAgent] Failed to parse params JSON from URL Scheme:', parseError);\\\n                                        processingMessage = `Warning: Failed to parse parameters from URL Scheme.`;\\\n                                    }\\\n                                }\\\n                                if (actionType) {\\\n                                    decidedActionFromUrl = { action: actionType, parameters: params, confidence: 1.0 };\\\n                                    processingMessage = `Identified action from URL Scheme: ${actionType}`;\\\n                                } else {\\\n                                     processingMessage = `Warning: URL Scheme missing action type.`;\\\n                                }\\\n                            } else if (host === 'share' && pathSegments.length === 0) {\\\n                                // Example: junai://share?data={...}\\\n                                const dataJson = parsedUrl.searchParams.get('data');\\\n                                let sharedData: any = {};\\\n                                if (dataJson) {\\\n                                    try {\\\n                                        sharedData = JSON.parse(dataJson);\\\n                                        // Decide what to do with shared data (e.g., create knowledge record, task, event)\\\n                                        // For MVP, simulate creating a knowledge record\\\n                                        decidedActionFromUrl = {\\\n                                            action: 'create_knowledge_point',\\\n                                            parameters: {\\\n                                                question: `Shared Data from URL Scheme (${eventPayload.source || 'unknown'})`,\\\n                                                answer: `Received shared data: ${JSON.stringify(sharedData)}`,\\\n                                                source: 'url-scheme-share',\\\n                                                tags: ['shared', 'url-scheme'],\\\n                                            },\\\\n                                            confidence: 1.0,\\\\n                                        };\\\\n                                        processingMessage = `Received shared data via URL Scheme. Suggesting to save as knowledge.`;\\\\n                                    } catch (parseError) {\\\\n                                        console.error('[InputAgent] Failed to parse shared data JSON from URL Scheme:', parseError);\\\\n                                        processingMessage = `Warning: Failed to parse shared data from URL Scheme.`;\\\\n                                    }\\\\n                                } else {\\\\n                                     processingMessage = `Warning: URL Scheme missing shared data.`;\\\\n                                }\\\\n                            }\\\\n                            // TODO: Add handlers for other internal schemes (e.g., junai://view?page=...)\\\\n                        } else if (scheme === 'working-copy' && host === 'x-callback-url' && pathSegments.length > 0) {\\\\n                            // Handle Working Copy x-callback-url commands\\\\n                            const command = pathSegments[0]; // e.g., 'read', 'write', 'commit'\\\\n                            const params: Record<string, any> = {};\\\\n                            parsedUrl.searchParams.forEach((value, key) => {\\\\n                                if (key !== 'key' && key !== 'x-success' && key !== 'x-error') { // Exclude x-callback params and key\\\\n                                     // Attempt to parse value as number or boolean if applicable\\\\n                                     let parsedValue: any = value;\\\\n                                     if (!isNaN(parseFloat(value)) && isFinite(value as any)) {\\\\n                                         parsedValue = parseFloat(value);\\\\n                                     } else if (value.toLowerCase() === 'true') {\\\\n                                         parsedValue = true;\\\\n                                     } else if (value.toLowerCase() === 'false') {\\\\n                                         parsedValue = false;\\\\n                                     }\\\\n                                     params[key] = parsedValue;\\\\n                                }\\\\n                            });\\\\n\\n                            // Decide on the action based on the Working Copy command\\\\n                            // This will trigger the WorkingCopyRune via the DeviceAgent\\\\n                            decidedActionFromUrl = {\\\\n                                action: 'interact_with_working_copy', // Generic action type for WC interaction\\\\n                                parameters: { command: command, params: params }, // Pass the command and its parameters\\\\n                                confidence: 1.0,\\\\n                            };\\\\n                            processingMessage = `Identified Working Copy command from URL Scheme: ${command}`;\\\\n\\n                        } else if (scheme === 'myapp' && host === 'x-callback-url' && pathSegments.length > 0) {\\\\n                            // Handle callbacks from external apps (e.g., Working Copy x-success/x-error)\\\\n                            const callbackType = pathSegments[0]; // e.g., 'workingcopy-callback'\\\\n                            const status = parsedUrl.searchParams.get('status'); // e.g., 'success', 'error'\\\\n                            const originalCommand = parsedUrl.searchParams.get('originalCommand'); // e.g., 'read', 'write'\\\\n                            const correlationId = parsedUrl.searchParams.get('correlationId'); // Original correlation ID\\\\n\\n                            console.log(`[InputAgent] Received x-callback-url callback: type=${callbackType}, status=${status}, originalCommand=${originalCommand}, correlationId=${correlationId}`);\\\\n                            processingMessage = `Received callback from external app (${callbackType}). Status: ${status}.`;\\\\n\\n                            // TODO: Implement logic to handle the callback\\\\n                            // - Find the original request using correlationId.\\\\n                            // - Update the status of the task/flow step that initiated the x-callback-url call.\\\\n                            // - Process the result data included in the callback parameters.\\\\n                            // - Publish an event indicating the callback was handled.\\\\n\\n                            // For MVP, just log the callback and maybe send a notification.\\n                            this.context.loggingService?.logInfo(`Received x-callback-url callback`, { userId, url, callbackType, status, originalCommand, correlationId });\\n                            if (this.context.agentFactory?.getAgent('notification')) {\\n                                this.sendMessage({\\n                                    type: 'send_notification',\\n                                    payload: {\\n                                        user_id: userId,\\n                                        type: status === 'success' ? 'success' : 'error',\\n                                        message: `Callback received from ${callbackType}. Status: ${status}. Original command: ${originalCommand}.`,\\n                                        channel: 'ui',\\n                                        details: { url, callbackType, status, originalCommand, correlationId },\\n                                    },\\n                                    recipient: 'notification',\\n                                    sender: this.agentName,\\n                                });\\n                            }\\n\\n                            // No ActionIntent is generated for a callback; it's a system event/update.\\n                            // Return success indicating the callback was received and logged/notified.\\n                            return { success: true, data: { message: processingMessage } };\\n\\n                        } else {\\n                            // Handle unknown URL schemes or formats\\n                            console.warn(`[InputAgent] Received unknown URL Scheme format: ${url}`);\\n                            processingMessage = `Warning: Received unknown URL Scheme format.`;\\n                            // Optionally fallback to reading the URL content if it's a standard URL\\n                            if (url.startsWith('http://') || url.startsWith('https://')) {\\n                                decidedActionFromUrl = { action: 'read_url', parameters: { url: url }, confidence: 0.5 }; // Suggest reading the URL\\n                                processingMessage += ` Suggesting to read URL content.`;\\n                            } else {\\n                                throw new Error(`Unsupported URL Scheme format: ${url}`);\\n                            }\\n                        }\\n\\n                    } catch (parseError: any) {\\n                        console.error('[InputAgent] Error parsing or handling URL Scheme:', parseError);\\n                        processingMessage = `Error parsing URL Scheme: ${parseError.message}`;\\n                        // If parsing fails, maybe fallback to a generic AI answer or error\\n                        decidedActionFromUrl = { action: 'answer_via_ai', parameters: { question: `I had trouble processing that URL Scheme: ${parseError.message}` }, confidence: 0.1 };\\n                    }\\n\\n\\n                    // If an action was decided from the URL Scheme, delegate its execution\\n                    if (decidedActionFromUrl) {\n                         console.log(`[InputAgent] Delegating execution of action decided from URL Scheme: ${decidedActionFromUrl.action}`);\n                         // Send the decided action as a new message to the InputAgent's own queue\n                         // Use a new correlationId for the execution, linked to the original URL Scheme message\n                         const executionCorrelationId = `exec-url-${decidedActionFromUrl.action}-${message.correlationId || 'N/A'}`;\\\n                         this.sendMessage({\\\n                             type: 'execute_action_intent', // Message type to execute a pre-defined action intent\\\n                             payload: { decision: decidedActionFromUrl, context: { ...executionContext, originalUrl: url, originalCorrelationId: message.correlationId } }, // Pass the ActionIntent and context\\\n                             recipient: this.agentName, // Send back to InputAgent for execution delegation\\\n                             correlationId: executionCorrelationId, // New correlation ID for execution\\\n                             sender: this.agentName, // Sender is InputAgent\\\n                         });\\\n\\\n                         // Return a success response indicating the action was delegated\\\n                         const successResponse: AgentResponse = { success: true, data: { message: processingMessage } };\\\n                         if (message.correlationId) {\\\n                             this.sendResponse(message, successResponse);\\\n                         }\\\n                         return successResponse;\\\n\\\n                    } else {\\\n                         // If no action was decided (e.g., just a warning message), return a success with the message\\\n                         const successResponse: AgentResponse = { success: true, data: { message: processingMessage } };\\\n                         if (message.correlationId) {\\\n                             this.sendResponse(message, successResponse);\\\n                         }\\\n                         return successResponse;\\\n                    }\\\n\\\n\n                default:\n                    console.warn(`[InputAgent] Unknown message type: ${message.type}`);\n                    // Return error response for unknown message types\n                    return { success: false, error: `Unknown message type for InputAgent: ${message.type}` };\n            }\n        } catch (error: any) {\n            console.error(`[InputAgent] Error handling message ${message.type} (Correlation ID: ${message.correlationId || 'N/A'}):`, error);\n            this.context.loggingService?.logError(`InputAgent error handling message ${message.type}.`, { messageType: message.type, correlationId: message.correlationId, error: error.message });\n\n            // If an error occurred, return an error response\n            return { success: false, error: error.message || 'An error occurred in InputAgent.' };\n        }\n    }\n\n    // TODO: Implement methods to send messages to other agents if needed\n    // e.g., notifying EvolutionAgent about a difficult-to-analyze input\n}\n```;
