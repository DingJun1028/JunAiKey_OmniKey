var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// packages/@junai/sdk/src/security.ts\n// Security Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { SystemEvent, UserAction, CloudSyncConfig } from '../../../src/interfaces'; // Import interfaces from main project\n\nexport class SecurityClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Retrieves recent security events for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, severity).\n   * @returns Promise<SystemEvent[]> An array of security events.\n   */\n  async getRecentSecurityEvents(userId: string, options?: { limit?: number, severity?: SystemEvent['severity'] }): Promise<SystemEvent[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/security/events?userId=...&limit=...&severity=...\n     // that delegates to the SecurityService/LoggingService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/events', 'GET', undefined, { params: { userId, ...options } });\n         return result as SystemEvent[]; // Assuming API returns an array of events\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('system_events').select('*').eq('user_id', userId).eq('type', 'security_event_recorded'); // Filter for security events\n         if (options?.severity) {\n             query = query.eq('severity', options.severity);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as SystemEvent[];\n     }\n  }\n\n   /**\n   * Retrieves recent user actions (personal usage logs) for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, type, searchTerm).\n   * @returns Promise<UserAction[]> An array of user actions.\n   */\n  async getRecentUserActions(userId: string, options?: { limit?: number, type?: string, searchTerm?: string }): Promise<UserAction[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/security/user-actions?userId=...&limit=...&type=...&searchTerm=...\n     // that delegates to the SecurityService/AuthorityForgingEngine.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/user-actions', 'GET', undefined, { params: { userId, ...options } });\n         return result as UserAction[]; // Assuming API returns an array of actions\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('user_actions').select('*').eq('user_id', userId);\n         if (options?.type) {\n             query = query.eq('type', options.type);\n         }\n         if (options?.searchTerm) {\n             // Basic text search filter on details/context (requires FTS setup in DB)\n             // For MVP fallback, simulate a basic filter or rely on FTS if configured.\n             // Let's simulate a basic ilike search on type and details text representation.\n             query = query.ilike('type', "], ["typescript\n// packages/@junai/sdk/src/security.ts\n// Security Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { SystemEvent, UserAction, CloudSyncConfig } from '../../../src/interfaces'; // Import interfaces from main project\n\nexport class SecurityClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Retrieves recent security events for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, severity).\n   * @returns Promise<SystemEvent[]> An array of security events.\n   */\n  async getRecentSecurityEvents(userId: string, options?: { limit?: number, severity?: SystemEvent['severity'] }): Promise<SystemEvent[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/security/events?userId=...&limit=...&severity=...\n     // that delegates to the SecurityService/LoggingService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/events', 'GET', undefined, { params: { userId, ...options } });\n         return result as SystemEvent[]; // Assuming API returns an array of events\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('system_events').select('*').eq('user_id', userId).eq('type', 'security_event_recorded'); // Filter for security events\n         if (options?.severity) {\n             query = query.eq('severity', options.severity);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as SystemEvent[];\n     }\n  }\n\n   /**\n   * Retrieves recent user actions (personal usage logs) for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, type, searchTerm).\n   * @returns Promise<UserAction[]> An array of user actions.\n   */\n  async getRecentUserActions(userId: string, options?: { limit?: number, type?: string, searchTerm?: string }): Promise<UserAction[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/security/user-actions?userId=...&limit=...&type=...&searchTerm=...\n     // that delegates to the SecurityService/AuthorityForgingEngine.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/user-actions', 'GET', undefined, { params: { userId, ...options } });\n         return result as UserAction[]; // Assuming API returns an array of actions\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('user_actions').select('*').eq('user_id', userId);\n         if (options?.type) {\n             query = query.eq('type', options.type);\n         }\n         if (options?.searchTerm) {\n             // Basic text search filter on details/context (requires FTS setup in DB)\n             // For MVP fallback, simulate a basic filter or rely on FTS if configured.\n             // Let's simulate a basic ilike search on type and details text representation.\n             query = query.ilike('type', "])) % $;
{
    options.searchTerm;
}
 % ").ilike('details::text', " % $;
{
    options.searchTerm;
}
 % ");\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as UserAction[];\n     }\n  }\n\n  /**\n   * Triggers a data integrity check for a user.\n   * @param userId The user ID. Required.\n   * @returns Promise<any> The results of the integrity check.\n   */\n  async triggerIntegrityCheck(userId: string): Promise<any> {\n     // This assumes your API Gateway has an endpoint like POST /api/v1/security/integrity-check\n     // that delegates to the SecurityService.\n     // Direct backend process triggering is not feasible in SDK.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/integrity-check', 'POST', { userId });\n         return result; // Assuming API returns a result object\n     } else {\n         // Fallback is not possible here as backend process triggering is required.\n         console.warn('SDK: Custom API endpoint not configured. Cannot trigger integrity check via SDK.');\n         throw new Error('Custom API endpoint is not configured. Cannot trigger integrity check via SDK.');\n     }\n  }\n\n   /**\n   * Triggers a security monitoring scan for a user.\n   * @param userId The user ID. Required.\n   * @returns Promise<any> The results of the security scan.\n   */\n  async triggerSecurityScan(userId: string): Promise<any> {\n     // This assumes your API Gateway has an endpoint like POST /api/v1/security/scan\n     // that delegates to the SecurityService.\n     // Direct backend process triggering is not feasible in SDK.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/security/scan', 'POST', { userId });\n         return result; // Assuming API returns a result object\n     } else {\n         // Fallback is not possible here as backend process triggering is required.\n         console.warn('SDK: Custom API endpoint not configured. Cannot trigger security scan via SDK.');\n         throw new Error('Custom API endpoint is not configured. Cannot trigger security scan via SDK.');\n     }\n  }\n\n   /**\n   * Resets all user data.\n   * WARNING: This is a destructive action.\n   * @param userId The user ID. Required.\n   * @returns Promise<void>\n   */\n  async resetUserData(userId: string): Promise<void> {\n     // This assumes your API Gateway has an endpoint like POST /api/v1/security/reset-data\n     // that delegates to the SecurityService.\n     // Direct backend process triggering is not feasible in SDK.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         await this.apiProxy.callApi('/api/v1/security/reset-data', 'POST', { userId });\n     } else {\n         // Fallback is not possible here as backend process triggering is required.\n         console.warn('SDK: Custom API endpoint not configured. Cannot reset user data via SDK.');\n         throw new Error('Custom API endpoint is not configured. Cannot reset user data via SDK.');\n     }\n  }\n\n   /**\n   * Triggers a full data backup for a user.\n   * @param userId The user ID. Required.\n   * @param destination Optional destination (e.g., 'google_drive', 'local_file'). Defaults to 'local_file'.\n   * @returns Promise<void>\n   */\n  async triggerBackup(userId: string, destination?: 'google_drive' | 'local_file'): Promise<void> {\n     // This assumes your API Gateway has an endpoint like POST /api/v1/security/backup\n     // that delegates to the SyncAgent/SyncService.\n     // Direct backend process triggering is not feasible in SDK.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         await this.apiProxy.callApi('/api/v1/security/backup', 'POST', { userId, destination });\n     } else {\n         // Fallback is not possible here as backend process triggering is required.\n         console.warn('SDK: Custom API endpoint not configured. Cannot trigger backup via SDK.');\n         throw new Error('Custom API endpoint is not configured. Cannot trigger backup via SDK.');\n     }\n  }\n\n   /**\n   * Triggers data mirroring for a user.\n   * @param userId The user ID. Required.\n   * @param dataType Optional data type to mirror. Defaults to 'system' (all data).\n   * @param destination Optional destination (e.g., 'boostspace', 'another_db'). Required.\n   * @returns Promise<void>\n   */\n  async triggerMirror(userId: string, dataType?: string, destination?: string): Promise<void> {\n     // This assumes your API Gateway has an endpoint like POST /api/v1/security/mirror\n     // that delegates to the SyncAgent/SyncService.\n     // Direct backend process triggering is not feasible in SDK.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         await this.apiProxy.callApi('/api/v1/security/mirror', 'POST', { userId, dataType, destination });\n     } else {\n         // Fallback is not possible here as backend process triggering is required.\n         console.warn('SDK: Custom API endpoint not configured. Cannot trigger mirroring via SDK.');\n         throw new Error('Custom API endpoint is not configured. Cannot trigger mirroring via SDK.');\n     }\n  }\n\n\n  // TODO: Add other security-related methods (e.g., getSensitiveDataKeys, storeSensitiveData, deleteSensitiveData, getLinkedIntegrations, updateSyncConfig)\n}\n"(__makeTemplateObject([""], [""]));
