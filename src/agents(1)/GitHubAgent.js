var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/GitHubAgent.ts\n// GitHub\u4EE3\u7406 (GitHub Agent)\n// Handles interactions with the GitHub API.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates GitHub specific logic.\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\n\n// Import existing services/runes this agent will interact with (temporarily)\n// In a full refactor, the logic from these services/runes might move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services/runes.\n// import { GitHubRune } from '../runes/GitHubRune'; // Import the GitHubRune\n\n\nexport class GitHubAgent extends BaseAgent {\n    // private gitHubRune: GitHubRune | null = null; // Reference to the GitHubRune\n\n    constructor(context: SystemContext) {\n        super('github', context);\n    }\n\n    /**\n     * Initializes the GitHub Agent by getting a reference to the GitHubRune.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Get reference to the GitHubRune from the RuneEngraftingCenter via context\n            // this.gitHubRune = this.context.sacredRuneEngraver?.runeImplementations.get('github-rune')?.instance || null; // Access internal map for MVP\n            // if (!this.gitHubRune) {\n            //      console.warn('[GitHubAgent] GitHubRune is not registered or available.');\n            //      // Handle error - maybe set agent status to unhealthy for GitHub features\n            // } else {\n            //      console.log('[GitHubAgent] GitHubRune obtained.');\n            // }\n        } catch (error) {\n            console.error('[GitHubAgent] Failed to get GitHubRune during init:', error);\n            // Handle error - maybe log or set agent status to unhealthy\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the GitHub Agent.\n     * Performs GitHub API calls by calling the GitHubRune.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the API result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("], ["typescript\n// src/agents/GitHubAgent.ts\n// GitHub\u4EE3\u7406 (GitHub Agent)\n// Handles interactions with the GitHub API.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates GitHub specific logic.\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\n\n// Import existing services/runes this agent will interact with (temporarily)\n// In a full refactor, the logic from these services/runes might move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services/runes.\n// import { GitHubRune } from '../runes/GitHubRune'; // Import the GitHubRune\n\n\nexport class GitHubAgent extends BaseAgent {\n    // private gitHubRune: GitHubRune | null = null; // Reference to the GitHubRune\n\n    constructor(context: SystemContext) {\n        super('github', context);\n    }\n\n    /**\n     * Initializes the GitHub Agent by getting a reference to the GitHubRune.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Get reference to the GitHubRune from the RuneEngraftingCenter via context\n            // this.gitHubRune = this.context.sacredRuneEngraver?.runeImplementations.get('github-rune')?.instance || null; // Access internal map for MVP\n            // if (!this.gitHubRune) {\n            //      console.warn('[GitHubAgent] GitHubRune is not registered or available.');\n            //      // Handle error - maybe set agent status to unhealthy for GitHub features\n            // } else {\n            //      console.log('[GitHubAgent] GitHubRune obtained.');\n            // }\n        } catch (error) {\n            console.error('[GitHubAgent] Failed to get GitHubRune during init:', error);\n            // Handle error - maybe log or set agent status to unhealthy\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the GitHub Agent.\n     * Performs GitHub API calls by calling the GitHubRune.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the API result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("]))[GitHubAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\n\n        const userId = this.context.currentUser?.id;\n        if (!userId) {\n             return { success: false, error: 'User not authenticated.' };\n        }\n\n        // Delegate to the GitHubRune via RuneEngraftingCenter\n        // This agent acts as a router/proxy to the Rune\n        if (!this.context.sacredRuneEngraver) { // Check if RuneEngraver is available\n             return { success: false, error: 'RuneEngraftingCenter is not available.' };\n        }\n\n        try {\n            let result: any;\n            switch (message.type) {\n                case 'callAPI': // Generic API call type, as defined in the Rune manifest\n                    // Payload: { endpoint: string, method: string, data?: any, config?: any }\n                    if (!message.payload?.endpoint || !message.payload?.method) {\n                         throw new Error('Endpoint and method are required for callAPI.');\n                    }\n                    // Request the action from the RuneEngraftingCenter\n                    result = await this.requestAgent(\n                        'rune_engrafting', // Target the RuneEngrafting Agent\n                        'execute_rune_action', // Message type for RuneEngrafting Agent\n                        {\n                            runeId: 'github-rune', // The specific Rune ID\n                            action: 'callAPI', // The action to execute on the rune\n                            params: message.payload, // Pass parameters to the rune action\n                        },\n                        15000 // Timeout for rune execution\n                    );\n                    // The result from requestAgent is already an AgentResponse from RuneEngraftingAgent.\n                    // We just return it directly.\n                    return result;\n\n\n                case 'getUser': // Specific GitHub task\n                    // Payload: {}\n                    // Request the action from the RuneEngraftingCenter\n                    result = await this.requestAgent(\n                        'rune_engrafting', // Target the RuneEngrafting Agent\n                        'execute_rune_action', // Message type for RuneEngrafting Agent\n                        {\n                            runeId: 'github-rune', // The specific Rune ID\n                            action: 'getUser', // The action to execute on the rune\n                            params: message.payload, // Pass parameters (should be empty for getUser)\n                        },\n                        10000 // Timeout for rune execution\n                    );\n                    // The result from requestAgent is already an AgentResponse from RuneEngraftingAgent.\n                    // We just return it directly.\n                    return result;\n\n\n                case 'listRepos': // Specific GitHub task\n                    // Payload: { type?: 'all' | 'owner' | 'member' }\n                    // Request the action from the RuneEngraftingCenter\n                    result = await this.requestAgent(\n                        'rune_engrafting', // Target the RuneEngrafting Agent\n                        'execute_rune_action', // Message type for RuneEngrafting Agent\n                        {\n                            runeId: 'github-rune', // The specific Rune ID\n                            action: 'listRepos', // The action to execute on the rune\n                            params: message.payload, // Pass parameters\n                        },\n                        15000 // Timeout for rune execution\n                    );\n                    // The result from requestAgent is already an AgentResponse from RuneEngraftingAgent.\n                    // We just return it directly.\n                    return result;\n\n\n                case 'createIssue': // Specific GitHub task\n                    // Payload: { owner: string, repo: string, title: string, body?: string, labels?: string[] }\n                    if (!message.payload?.owner || !message.payload?.repo || !message.payload?.title) {\n                         throw new Error('owner, repo, and title are required for createIssue.');\n                    }\n                    // Request the action from the RuneEngraftingCenter\n                    result = await this.requestAgent(\n                        'rune_engrafting', // Target the RuneEngrafting Agent\n                        'execute_rune_action', // Message type for RuneEngrafting Agent\n                        {\n                            runeId: 'github-rune', // The specific Rune ID\n                            action: 'createIssue', // The action to execute on the rune\n                            params: message.payload, // Pass parameters\n                        },\n                        20000 // Timeout for rune execution\n                    );\n                    // The result from requestAgent is already an AgentResponse from RuneEngraftingAgent.\n                    // We just return it directly.\n                    return result;\n\n\n                // TODO: Add cases for other GitHub tasks if needed (e.g., 'getRepoContent', 'createCommit', 'listPullRequests')\n\n                default:\n                    console.warn("[GitHubAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");\n                    return { success: false, error: ";
Unknown;
message;
type;
for (GitHubAgent; ; )
    : $;
{
    message.type;
}
" };\n            }\n        } catch (error: any) {\n            console.error("[GitHubAgent];
Error;
handling;
message;
$;
{
    message.type;
}
", error);\n            return { success: false, error: error.message || 'An error occurred in GitHubAgent.' };\n        }\n    }\n\n    // TODO: Implement methods to send messages to other agents if needed\n}\n"(__makeTemplateObject([""], [""]));
