var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// packages/@junai/sdk/src/analytics.ts\n// Analytics Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { SystemEvent, UserAction } from '../../../src/interfaces'; // Import interfaces from main project\n\nexport class AnalyticsClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Calculates Key Performance Indicators (KPIs) for a user.\n   * @param userId The user ID. Required.\n   * @param timeframe Optional timeframe (e.g., 'day', 'week', 'month', 'all'). Defaults to 'all'.\n   * @returns Promise<any> An object containing calculated KPIs.\n   */\n  async getKPIs(userId: string, timeframe?: 'day' | 'week' | 'month' | 'all'): Promise<any> {\n    // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/kpis?userId=...&timeframe=...\n    // that delegates to the AnalyticsAgent/AnalyticsService.\n    // Direct Supabase calculation is complex and not feasible in SDK.\n\n    if (this.apiProxy.getApiEndpoint()) {\n        // Call custom API Gateway\n        const result = await this.apiProxy.callApi('/api/v1/analytics/kpis', 'GET', undefined, { params: { userId, timeframe } });\n        return result; // Assuming API returns the KPI object\n    } else {\n        // Fallback is not possible here as KPI calculation requires backend processing.\n        console.warn('SDK: Custom API endpoint not configured. Cannot calculate KPIs via SDK.');\n        throw new Error('Custom API endpoint is not configured. Cannot calculate KPIs via SDK.');\n    }\n  }\n\n  /**\n   * Retrieves recent system events for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, severity).\n   * @returns Promise<SystemEvent[]> An array of system events.\n   */\n  async getRecentSystemEvents(userId: string, options?: { limit?: number, severity?: SystemEvent['severity'] }): Promise<SystemEvent[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/system-events?userId=...&limit=...&severity=...\n     // that delegates to the AnalyticsAgent/LoggingService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/analytics/system-events', 'GET', undefined, { params: { userId, ...options } });\n         return result as SystemEvent[]; // Assuming API returns an array of events\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('system_events').select('*').eq('user_id', userId);\n         if (options?.severity) {\n             query = query.eq('severity', options.severity);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as SystemEvent[];\n     }\n  }\n\n   /**\n   * Retrieves recent user actions for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, type, searchTerm).\n   * @returns Promise<UserAction[]> An array of user actions.\n   */\n  async getRecentUserActions(userId: string, options?: { limit?: number, type?: string, searchTerm?: string }): Promise<UserAction[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/user-actions?userId=...&limit=...&type=...&searchTerm=...\n     // that delegates to the AnalyticsAgent/AuthorityForgingEngine.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/analytics/user-actions', 'GET', undefined, { params: { userId, ...options } });\n         return result as UserAction[]; // Assuming API returns an array of actions\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('user_actions').select('*').eq('user_id', userId);\n         if (options?.type) {\n             query = query.eq('type', options.type);\n         }\n         if (options?.searchTerm) {\n             // Basic text search filter on details/context (requires FTS setup in DB)\n             // For MVP fallback, simulate a basic filter or rely on FTS if configured.\n             // Let's simulate a basic ilike search on type and details text representation.\n             query = query.ilike('type', "], ["typescript\n// packages/@junai/sdk/src/analytics.ts\n// Analytics Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { SystemEvent, UserAction } from '../../../src/interfaces'; // Import interfaces from main project\n\nexport class AnalyticsClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Calculates Key Performance Indicators (KPIs) for a user.\n   * @param userId The user ID. Required.\n   * @param timeframe Optional timeframe (e.g., 'day', 'week', 'month', 'all'). Defaults to 'all'.\n   * @returns Promise<any> An object containing calculated KPIs.\n   */\n  async getKPIs(userId: string, timeframe?: 'day' | 'week' | 'month' | 'all'): Promise<any> {\n    // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/kpis?userId=...&timeframe=...\n    // that delegates to the AnalyticsAgent/AnalyticsService.\n    // Direct Supabase calculation is complex and not feasible in SDK.\n\n    if (this.apiProxy.getApiEndpoint()) {\n        // Call custom API Gateway\n        const result = await this.apiProxy.callApi('/api/v1/analytics/kpis', 'GET', undefined, { params: { userId, timeframe } });\n        return result; // Assuming API returns the KPI object\n    } else {\n        // Fallback is not possible here as KPI calculation requires backend processing.\n        console.warn('SDK: Custom API endpoint not configured. Cannot calculate KPIs via SDK.');\n        throw new Error('Custom API endpoint is not configured. Cannot calculate KPIs via SDK.');\n    }\n  }\n\n  /**\n   * Retrieves recent system events for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, severity).\n   * @returns Promise<SystemEvent[]> An array of system events.\n   */\n  async getRecentSystemEvents(userId: string, options?: { limit?: number, severity?: SystemEvent['severity'] }): Promise<SystemEvent[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/system-events?userId=...&limit=...&severity=...\n     // that delegates to the AnalyticsAgent/LoggingService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/analytics/system-events', 'GET', undefined, { params: { userId, ...options } });\n         return result as SystemEvent[]; // Assuming API returns an array of events\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('system_events').select('*').eq('user_id', userId);\n         if (options?.severity) {\n             query = query.eq('severity', options.severity);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as SystemEvent[];\n     }\n  }\n\n   /**\n   * Retrieves recent user actions for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., limit, type, searchTerm).\n   * @returns Promise<UserAction[]> An array of user actions.\n   */\n  async getRecentUserActions(userId: string, options?: { limit?: number, type?: string, searchTerm?: string }): Promise<UserAction[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/analytics/user-actions?userId=...&limit=...&type=...&searchTerm=...\n     // that delegates to the AnalyticsAgent/AuthorityForgingEngine.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/analytics/user-actions', 'GET', undefined, { params: { userId, ...options } });\n         return result as UserAction[]; // Assuming API returns an array of actions\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('user_actions').select('*').eq('user_id', userId);\n         if (options?.type) {\n             query = query.eq('type', options.type);\n         }\n         if (options?.searchTerm) {\n             // Basic text search filter on details/context (requires FTS setup in DB)\n             // For MVP fallback, simulate a basic filter or rely on FTS if configured.\n             // Let's simulate a basic ilike search on type and details text representation.\n             query = query.ilike('type', "])) % $;
{
    options.searchTerm;
}
 % ").ilike('details::text', " % $;
{
    options.searchTerm;
}
 % ");\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as UserAction[];\n     }\n  }\n\n\n  // TODO: Add other analytics-related methods (e.g., getUserActivitySummary, getReports)\n}\n"(__makeTemplateObject([""], [""]));
