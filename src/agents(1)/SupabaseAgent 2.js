var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/SupabaseAgent.ts\n// Supabase\u4EE3\u7406 (Supabase Agent)\n// Handles direct interactions with the Supabase client.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates database access logic.\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { SupabaseClient } from '@supabase/supabase-js'; // Import SupabaseClient\n\n\nexport class SupabaseAgent extends BaseAgent {\n    private supabase: SupabaseClient;\n\n    constructor(context: SystemContext) {\n        super('supabase', context);\n        // Get Supabase client from context (initialized by SecurityService)\n        this.supabase = context.securityService?.supabase;\n\n        if (!this.supabase) {\n             console.error('[SupabaseAgent] Supabase client is not available in context.');\n             // Handle error - maybe set agent status to unhealthy\n        }\n    }\n\n    /**\n     * Handles messages directed to the Supabase Agent.\n     * Performs database operations using the Supabase client.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the DB operation result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("], ["typescript\n// src/agents/SupabaseAgent.ts\n// Supabase\\u4ee3\\u7406 (Supabase Agent)\n// Handles direct interactions with the Supabase client.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates database access logic.\n\nimport { SystemContext } from '../../interfaces'; // Assuming SystemContext interface exists\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { SupabaseClient } from '@supabase/supabase-js'; // Import SupabaseClient\n\n\nexport class SupabaseAgent extends BaseAgent {\n    private supabase: SupabaseClient;\n\n    constructor(context: SystemContext) {\n        super('supabase', context);\n        // Get Supabase client from context (initialized by SecurityService)\n        this.supabase = context.securityService?.supabase;\n\n        if (!this.supabase) {\n             console.error('[SupabaseAgent] Supabase client is not available in context.');\n             // Handle error - maybe set agent status to unhealthy\n        }\n    }\n\n    /**\n     * Handles messages directed to the Supabase Agent.\n     * Performs database operations using the Supabase client.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the DB operation result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\n        console.log("]))[SupabaseAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\n\n        if (!this.supabase) {\n             return { success: false, error: 'Supabase client is not initialized.' };\n        }\n\n        const userId = this.context.currentUser?.id;\n        // Note: Some Supabase operations (like public reads or service role calls) might not require a logged-in user.\n        // However, for most user data operations, userId is needed for RLS.\n        // Let's add a check if the operation *requires* a user. For now, assume most do.\n        // If an operation doesn't require a user, the RLS policy should allow it.\n\n        try {\n            let result: any;\n            let error: any;\n\n            switch (message.type) {\n                case 'insert_record':\n                    // Payload: { table: string, record: any }\n                    if (!message.payload?.table || !message.payload?.record) {\n                         throw new Error('Table and record are required for insert_record.');\n                    }\n                    // Ensure user_id is added to the record if not present and required by RLS\n                    if (userId && !message.payload.record.user_id) {\n                         message.payload.record.user_id = userId;\n                    }\n                    ({ data: result, error } = await this.supabase\n                        .from(message.payload.table)\n                        .insert([message.payload.record])\n                        .select() // Select the inserted data\n                        .single()); // Expecting a single record back\n                    break;\n\n                case 'query_records':\n                    // Payload: { table: string, query?: any, select?: string, limit?: number, order?: { column: string, ascending: boolean } }\n                    if (!message.payload?.table) {\n                         throw new Error('Table is required for query_records.');\n                    }\n                    let query = this.supabase.from(message.payload.table).select(message.payload.select || '*');\n                    if (message.payload.query) {\n                        query = query.match(message.payload.query); // Apply match filter\n                    }\n                    // Add user_id filter if user is logged in and table has user_id (RLS should handle this, but explicit filter is safer)\n                    // This is complex to do generically. Rely on RLS for filtering.\n                    if (message.payload.limit !== undefined) {\n                        query = query.limit(message.payload.limit);\n                    }\n                    if (message.payload.order) {\n                        query = query.order(message.payload.order.column, { ascending: message.payload.order.ascending });\n                    }\n                    ({ data: result, error } = await query);\n                    break;\n\n                case 'update_record':\n                    // Payload: { table: string, id: string, updates: any }\n                    if (!message.payload?.table || !message.payload?.id || !message.payload?.updates) {\n                         throw new Error('Table, id, and updates are required for update_record.');\n                    }                    // RLS should ensure user can only update their own records.                    ({ data: result, error } = await this.supabase                        .from(message.payload.table)                        .update(message.payload.updates)                        .eq('id', message.payload.id)                        // Add user_id filter here explicitly for safety, even if RLS is on                        // .eq('user_id', userId) // This requires knowing the table has a user_id column                        .select() // Select the updated data                        .single()); // Expecting a single record back                    break;                case 'delete_record':                    // Payload: { table: string, id: string }                    if (!message.payload?.table || !message.payload?.id) {                         throw new Error('Table and id are required for delete_record.');                    }                    // RLS should ensure user can only delete their own records.                    ({ data: result, error } = await this.supabase                        .from(message.payload.table)                        .delete()                        .eq('id', message.payload.id)                         // Add user_id filter here explicitly for safety, even if RLS is on                        // .eq('user_id', userId) // This requires knowing the table has a user_id column                        .select('id') // Select ID to confirm deletion                        .single()); // Expecting a single record back                    break;                case 'call_rpc':                    // Payload: { functionName: string, params?: any, useServiceRole?: boolean }                    if (!message.payload?.functionName) {                         throw new Error('functionName is required for call_rpc.');                    }                     // Note: Handling useServiceRole securely requires context/permissions check                    // For MVP, we'll allow passing useServiceRole flag, but the SecurityService                    // should enforce that only authorized agents/contexts can use it.                    // The Supabase client instance from SecurityService might be configured                    // differently (e.g., anon vs authenticated vs service role).                    // Using the client from context means it's the authenticated user's client.                    // To use service role, we'd need a separate client instance or method.                    // Let's assume for MVP that the client from context is sufficient,                    // and RLS/RPC definitions handle permissions.                    ({ data: result, error } = await this.supabase.rpc(message.payload.functionName, message.payload.params));                    break;                // TODO: Add cases for other Supabase operations (storage, auth admin, etc.)                // case 'upload_file': // Payload: { bucket: string, path: string, file: File | Blob | ArrayBuffer }                // case 'delete_file': // Payload: { bucket: string, path: string }                // case 'list_files': // Payload: { bucket: string, path?: string }                // case 'delete_user': // Payload: { userId: string } (requires admin)                default:                    console.warn("[SupabaseAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");                    return { success: false, error: ";
Unknown;
message;
type;
for (SupabaseAgent; ; )
    : $;
{
    message.type;
}
" };            }            if (error) {                console.error("[SupabaseAgent];
Supabase;
operation;
failed($, { message: message, : .type });
", error.message);                // TODO: Log error using LoggingService                return { success: false, error: error.message };            }            console.log("[SupabaseAgent];
Supabase;
operation;
successful($, { message: message, : .type }).(__makeTemplateObject([");            return { success: true, data: result };        } catch (error: any) {            console.error("], [");\\\n            return { success: true, data: result };\\\n\\\n        } catch (error: any) {\\\n            console.error("]))[SupabaseAgent];
Unexpected;
error;
handling;
message;
$;
{
    message.type;
}
", error);            // TODO: Log error using LoggingService            return { success: false, error: error.message || 'An unexpected error occurred in SupabaseAgent.' };        }    }    // TODO: Implement methods to send messages to other agents if needed}"(__makeTemplateObject([""], [""]));
