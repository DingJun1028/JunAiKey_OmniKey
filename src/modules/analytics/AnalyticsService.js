var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject([void 0], ["typescript\n// src/modules/analytics/AnalyticsService.ts\n// \\u5206\\u6790\\u670d\\u52d9 (Analytics Service) - \\u8f1\u8F14\\u52a9\\u6a21\\u7d44\n// Collects, processes, and analyzes system data and user behavior.\n// Calculates Key Performance Indicators (KPIs) and provides data for the Evolution Engine.\n// Part of the Six Styles of Infinite Evolution (\\u7121\\u9650\\u9032\\u5316\\u5faa\\u74b0\\u7684\\u516d\\u5f0f\\u5967\\u7fa9) - specifically Observe (\\u89c0\\u5bdf) and Monitor (\\u76e3\\u63a7).\n// Design Principle: Provides data-driven insights into system usage and performance.\n\nimport { SystemContext, UserAction, Task, Rune, EvolutionaryInsight, Goal, KeyResult, SystemEvent, ForgedAbility } from '../../interfaces'; // Import ForgedAbility\nimport { SupabaseClient } from '@supabase/supabase-js';\n// import { LoggingService } from '../../core/logging/LoggingService'; // Dependency\n// import { EventBus } from '../events/EventBus'; // Dependency\n// import { AuthorityForgingEngine } from '../../core/authority/AuthorityForgingEngine'; // Dependency for fetching actions/abilities\n// import { SelfNavigationEngine } from '../../core/self-navigation/SelfNavigationEngine'; // Dependency for fetching tasks\n// import { RuneEngraftingCenter } from '../../core/rune-engrafting/RuneEngraftingCenter'; // Dependency for fetching runes\n// import { GoalManagementService } from '../../core/goal-management/GoalManagementService'; // Dependency for fetching goals\n// import { KnowledgeSync } from '../../modules/knowledgeSync'; // Dependency for fetching knowledge records\n\n\nexport class AnalyticsService {\n    private context: SystemContext;\n    private supabase: SupabaseClient;\n    // private loggingService: LoggingService; // Access via context\n    // private eventBus: EventBus; // Access via context\n    // private authorityForgingEngine: AuthorityForgingEngine; // Access via context\n    // private selfNavigationEngine: SelfNavigationEngine; // Access via context\n    // private runeEngraftingCenter: RuneEngraftingCenter; // Access via context\n    // private goalManagementService: GoalManagementService; // Access via context\n    // private knowledgeSync: KnowledgeSync; // Access via context\n\n\n    constructor(context: SystemContext) {\n        this.context = context;\n        this.supabase = context.apiProxy.supabaseClient; // Use the Supabase client from ApiProxy\n        // this.loggingService = context.loggingService;\n        // this.eventBus = context.eventBus;\n        // this.authorityForgingEngine = context.authorityForgingEngine;\n        // this.selfNavigationEngine = context.selfNavigationEngine;\n        // this.runeEngraftingCenter = context.runeEngraftingCenter;\n        // this.goalManagementService = context.goalManagementService;\n        // this.knowledgeSync = context.knowledgeSync;\n        console.log('AnalyticsService initialized.');\n\n        // TODO: Set up listeners for relevant events to collect data in realtime (Supports Event Push)\n        // Example: this.context.eventBus.subscribe('user_action_recorded', (payload) => this.handleUserAction(payload));\n        // Example: this.context.eventBus.subscribe('task_completed', (payload) => this.handleTaskCompleted(payload));\n        // Example: this.context.eventBus.subscribe('rune_action_executed', (payload) => this.handleRuneActionExecuted(payload));\n    }\n\n    /**\n     * Helper to get the start date based on the timeframe.\n     * @param timeframe The timeframe (e.g., 'day', 'week', 'month', 'all').\n     * @returns Date | undefined The start date or undefined for 'all'.\n     */\n    private getStartDate(timeframe: 'day' | 'week' | 'month' | 'all'): Date | undefined {\n        const now = new Date();\n        switch (timeframe) {\n            case 'day': return new Date(now.setDate(now.getDate() - 1));\n            case 'week': return new Date(now.setDate(now.getDate() - 7));\n            case 'month': return new Date(now.setMonth(now.getMonth() - 1));\n            case 'all': return undefined;\n            default: return undefined;\n        }\n    }\n\n    /**\n     * Collects raw data from various sources for analysis.\n     * This is a core part of the \\\"Observe\\\" step.\n     * @param userId The user ID to collect data for. Required.\n     * @param timeframe Optional timeframe (e.g., 'day', 'week', 'month', 'all'). Defaults to 'all'.\n     * @returns Promise<any> An object containing collected raw data.\n     */\n    private async collectRawData(userId: string, timeframe: 'day' | 'week' | 'month' | 'all' = 'all'): Promise<{\\n        userActions: UserAction[];\\n        tasks: Task[];\\n        runes: Rune[]; // Note: Runes are definitions, not executions. Execution data is in user_actions/system_events.\\n        abilities: ForgedAbility[]; // Abilities are definitions\\n        goals: Goal[];\\n        systemEvents: SystemEvent[];\\n        knowledgeRecords: KnowledgeRecord[]; // Added knowledge records\\n        // Add other data sources like logs, notifications, etc.\\n    }> {\\n        console.log("]))[AnalyticsService];
Collecting;
raw;
data;
for (user; ; )
    : $;
{
    userId;
}
timeframe: $;
{
    timeframe;
}
");\n        this.context.loggingService?.logInfo(";
Collecting;
raw;
data;
for (user; $; { userId: userId }(__makeTemplateObject([", { userId, timeframe });\n\n        const startDate = this.getStartDate(timeframe);\n        const startDateISO = startDate?.toISOString();\n\n\n        // Fetch data from Supabase (or other sources)\n        // NOTE: For MVP, fetching directly from Supabase tables.\n        // In a more mature version, consider using public methods of\n        // AuthorityForgingEngine, SelfNavigationEngine, etc., if those methods\n        // support efficient fetching with timeframe filters.\n        // Direct DB access here bypasses service-specific logic but is simpler for MVP analytics.\n\n        let userActions: UserAction[] = [];\n        try {\n             let query = this.supabase.from('user_actions').select('*').eq('user_id', userId);\n             if (startDateISO) {\n                 query = query.gte('timestamp', startDateISO);\n             }\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\n             if (error) throw error;\n             userActions = data as UserAction[];\n             console.log("], [", { userId, timeframe });\\n\\n        const startDate = this.getStartDate(timeframe);\\n        const startDateISO = startDate?.toISOString();\\n\\n\\n        // Fetch data from Supabase (or other sources)\\n        // NOTE: For MVP, fetching directly from Supabase tables.\\n        // In a more mature version, consider using public methods of\\n        // AuthorityForgingEngine, SelfNavigationEngine, etc., if those methods\\n        // support efficient fetching with timeframe filters.\\n        // Direct DB access here bypasses service-specific logic but is simpler for MVP analytics.\\n\\n        let userActions: UserAction[] = [];\\n        try {\\n             let query = this.supabase.from('user_actions').select('*').eq('user_id', userId);\\n             if (startDateISO) {\\n                 query = query.gte('timestamp', startDateISO);\\n             }\\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\\n             if (error) throw error;\\n             userActions = data as UserAction[];\\n             console.log("]))[AnalyticsService])
    Fetched;
$;
{
    userActions.length;
}
user;
actions.(__makeTemplateObject([");\n        } catch (error: any) {\n             console.error('[AnalyticsService] Error fetching user actions:', error.message);\n             this.context.loggingService?.logError('Error fetching user actions for analytics', { userId, timeframe, error: error.message });\n        }\n\n\n        let tasks: Task[] = [];\n        try {\n             // Fetch tasks created within the timeframe, including steps\n             let query = this.supabase.from('tasks').select('*, task_steps(*)').eq('user_id', userId);\n              if (startDateISO) {\n                 query = query.gte('creation_timestamp', startDateISO);\n             }\n             const { data, error } = await query.order('creation_timestamp', { ascending: false } as any);\n             if (error) throw error;\n             tasks = (data as Task[]).map(task => ({\n                 ...task,\n                 steps: task.steps.sort((a, b) => a.step_order - b.step_order) // Ensure steps are sorted\n             }));\n             console.log("], [");\\n        } catch (error: any) {\\n             console.error('[AnalyticsService] Error fetching user actions:', error.message);\\n             this.context.loggingService?.logError('Error fetching user actions for analytics', { userId, timeframe, error: error.message });\\n        }\\n\\n\\n        let tasks: Task[] = [];\\n        try {\\n             // Fetch tasks created within the timeframe, including steps\\n             let query = this.supabase.from('tasks').select('*, task_steps(*)').eq('user_id', userId);\\n              if (startDateISO) {\\n                 query = query.gte('creation_timestamp', startDateISO);\\n             }\\n             const { data, error } = await query.order('creation_timestamp', { ascending: false } as any);\\n             if (error) throw error;\\n             tasks = (data as Task[]).map(task => ({\\n                 ...task,\\n                 steps: task.steps.sort((a, b) => a.step_order - b.step_order) // Ensure steps are sorted\\n             }));\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    tasks.length;
}
tasks.(__makeTemplateObject([");\n        } catch (error: any) {\n             console.error('[AnalyticsService] Error fetching tasks:', error.message);\n             this.context.loggingService?.logError('Error fetching tasks for analytics', { userId, timeframe, error: error.message });\n        }\n\n\n        let runes: Rune[] = [];\n         try {\n             // Fetch all runes (user's and public) - timeframe doesn't apply to definitions\n             // Using RuneEngraftingCenter method here is appropriate as it fetches definitions\n             runes = await this.context.runeEngraftingCenter?.listRunes(undefined, userId) || [];\n             console.log("], [");\\n        } catch (error: any) {\\n             console.error('[AnalyticsService] Error fetching tasks:', error.message);\\n             this.context.loggingService?.logError('Error fetching tasks for analytics', { userId, timeframe, error: error.message });\\n        }\\n\\n\\n        let runes: Rune[] = [];\\n         try {\\n             // Fetch all runes (user's and public) - timeframe doesn't apply to definitions\\n             // Using RuneEngraftingCenter method here is appropriate as it fetches definitions\\n             runes = await this.context.runeEngraftingCenter?.listRunes(undefined, userId) || [];\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    runes.length;
}
rune;
definitions.(__makeTemplateObject([");\n         } catch (error: any) {\n              console.error('[AnalyticsService] Error fetching rune definitions:', error.message);\n              this.context.loggingService?.logError('Error fetching rune definitions for analytics', { userId, error: error.message });\n         }\n\n        let abilities: ForgedAbility[] = [];\n         try {\n             // Fetch all abilities (user's and public) - timeframe doesn't apply to definitions\n             // Using AuthorityForgingEngine method here is appropriate\n             abilities = await this.context.authorityForgingEngine?.getAbilities(undefined, userId) || [];\n             console.log("], [");\\n         } catch (error: any) {\\n              console.error('[AnalyticsService] Error fetching rune definitions:', error.message);\\n              this.context.loggingService?.logError('Error fetching rune definitions for analytics', { userId, error: error.message });\\n         }\\n\\n        let abilities: ForgedAbility[] = [];\\n         try {\\n             // Fetch all abilities (user's and public) - timeframe doesn't apply to definitions\\n             // Using AuthorityForgingEngine method here is appropriate\\n             abilities = await this.context.authorityForgingEngine?.getAbilities(undefined, userId) || [];\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    abilities.length;
}
ability;
definitions.(__makeTemplateObject([");\n         } catch (error: any) {\n              console.error('[AnalyticsService] Error fetching ability definitions:', error.message);\n              this.context.loggingService?.logError('Error fetching ability definitions for analytics', { userId, error: error.message });\n         }\n\n\n        let goals: Goal[] = [];\n         try {\n             // Fetch goals created within the timeframe, including key results\n             let query = this.supabase.from('goals').select('*, key_results(*)').eq('user_id', userId);\n              if (startDateISO) {\n                 query = query.gte('creation_timestamp', startDateISO);\n             }\n             const { data, error } = await query.order('creation_timestamp', { ascending: false } as any);\n             if (error) throw error;\n             goals = data as Goal[];\n             console.log("], [");\\n         } catch (error: any) {\\n              console.error('[AnalyticsService] Error fetching ability definitions:', error.message);\\n              this.context.loggingService?.logError('Error fetching ability definitions for analytics', { userId, error: error.message });\\n         }\\n\\n\\n        let goals: Goal[] = [];\\n         try {\\n             // Fetch goals created within the timeframe, including key results\\n             let query = this.supabase.from('goals').select('*, key_results(*)').eq('user_id', userId);\\n              if (startDateISO) {\\n                 query = query.gte('creation_timestamp', startDateISO);\\n             }\\n             const { data, error } = await query.order('creation_timestamp', { ascending: false } as any);\\n             if (error) throw error;\\n             goals = data as Goal[];\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    goals.length;
}
goals.(__makeTemplateObject([");\n         } catch (error: any) {\n              console.error('[AnalyticsService] Error fetching goals:', error.message);\n              this.context.loggingService?.logError('Error fetching goals for analytics', { userId, timeframe, error: error.message });\n         }\n\n\n        let systemEvents: SystemEvent[] = [];\n         try {\n             // Fetch system events within the timeframe\n             let query = this.supabase.from('system_events').select('*').eq('user_id', userId);\n              if (startDateISO) {\n                 query = query.gte('timestamp', startDateISO);\n             }\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\n             if (error) throw error;\n             systemEvents = data as SystemEvent[];\n             console.log("], [");\\n         } catch (error: any) {\\n              console.error('[AnalyticsService] Error fetching goals:', error.message);\\n              this.context.loggingService?.logError('Error fetching goals for analytics', { userId, timeframe, error: error.message });\\n         }\\n\\n\\n        let systemEvents: SystemEvent[] = [];\\n         try {\\n             // Fetch system events within the timeframe\\n             let query = this.supabase.from('system_events').select('*').eq('user_id', userId);\\n              if (startDateISO) {\\n                 query = query.gte('timestamp', startDateISO);\\n             }\\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\\n             if (error) throw error;\\n             systemEvents = data as SystemEvent[];\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    systemEvents.length;
}
system;
events.(__makeTemplateObject([");\n         } catch (error: any) {\n              console.error('[AnalyticsService] Error fetching system events:', error.message);\n              this.context.loggingService?.logError('Error fetching system events for analytics', { userId, timeframe, error: error.message });\n         }\n\n        let knowledgeRecords: KnowledgeRecord[] = [];\n         try {\n             // Fetch knowledge records within the timeframe\n             let query = this.supabase.from('knowledge_records').select('*').eq('user_id', userId);\n              if (startDateISO) {\n                 query = query.gte('timestamp', startDateISO);\n             }\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\n             if (error) throw error;\n             knowledgeRecords = data as KnowledgeRecord[];\n             console.log("], [");\\n         } catch (error: any) {\\n              console.error('[AnalyticsService] Error fetching system events:', error.message);\\n              this.context.loggingService?.logError('Error fetching system events for analytics', { userId, timeframe, error: error.message });\\n         }\\n\\n        let knowledgeRecords: KnowledgeRecord[] = [];\\n         try {\\n             // Fetch knowledge records within the timeframe\\n             let query = this.supabase.from('knowledge_records').select('*').eq('user_id', userId);\\n              if (startDateISO) {\\n                 query = query.gte('timestamp', startDateISO);\\n             }\\n             const { data, error } = await query.order('timestamp', { ascending: false } as any);\\n             if (error) throw error;\\n             knowledgeRecords = data as KnowledgeRecord[];\\n             console.log("]))[AnalyticsService];
Fetched;
$;
{
    knowledgeRecords.length;
}
knowledge;
records.(__makeTemplateObject([");\n         } catch (error: any) {\n              console.error('[AnalyticsService] Error fetching knowledge records:', error.message);\n              this.context.loggingService?.logError('Error fetching knowledge records for analytics', { userId, timeframe, error: error.message });\n         }\n\n\n        // TODO: Fetch other data sources (e.g., logs from LoggingService, notifications from NotificationService)\n\n        console.log("], [");\\n         } catch (error: any) {\\n              console.error('[AnalyticsService] Error fetching knowledge records:', error.message);\\n              this.context.loggingService?.logError('Error fetching knowledge records for analytics', { userId, timeframe, error: error.message });\\n         }\\n\\n\\n        // TODO: Fetch other data sources (e.g., logs from LoggingService, notifications from NotificationService)\\n\\n        console.log("]))[AnalyticsService];
Raw;
data;
collection;
complete;
for (user; ; )
    : $;
{
    userId;
}
");\n        return {\n            userActions,\n            tasks,\n            runes,\n            abilities, // Include abilities\n            goals,\n            systemEvents,\n            knowledgeRecords, // Include knowledge records\n            // Include other collected data\n        };\n    }\n\n\n    /**\n     * Calculates Key Performance Indicators (KPIs) based on collected data.\n     * Part of the \"Monitor\" step.\n     * @param timeframe The timeframe for calculation (e.g., 'day', 'week', 'month', 'all'). Required.\n     * @param userId The user ID for calculation. Required.\n     * @returns Promise<any> An object containing calculated KPIs.\n     */\n    async calculateKPIs(timeframe: 'day' | 'week' | 'month' | 'all', userId: string): Promise<any> {\n        console.log("[AnalyticsService];
Calculating;
KPIs;
for (user; ; )
    : $;
{
    userId;
}
timeframe: $;
{
    timeframe;
}
");\n        this.context.loggingService?.logInfo(";
Calculating;
KPIs;
for (user; $; { userId: userId }(__makeTemplateObject([", { userId, timeframe });\n\n        if (!userId) {\n            console.error('[AnalyticsService] Cannot calculate KPIs: User ID is required.');\n            this.context.loggingService?.logError('Cannot calculate KPIs: User ID is required.');\n            throw new Error('User ID is required to calculate KPIs.');\n        }\n\n        // Collect the necessary raw data for the specified timeframe\n        const rawData = await this.collectRawData(userId, timeframe);\n        const { userActions, tasks, systemEvents, runes, abilities, goals, knowledgeRecords } = rawData; // Destructure relevant data\n\n\n        // --- Calculate KPIs ---\n        let taskCompletionRate = 0;\n        let totalTasksCompleted = 0;\n        let totalTasksFailed = 0;\n        let totalTasksCancelled = 0;\n        let totalTasksStarted = 0; // Tasks that reached 'in-progress' status\n\n        tasks.forEach(task => {\n            if (task.status === 'completed') totalTasksCompleted++;\n            if (task.status === 'failed') totalTasksFailed++;\n            if (task.status === 'cancelled') totalTasksCancelled++;\n            if (task.start_timestamp) totalTasksStarted++; // Count tasks that were started\n        });\n\n        const totalTasksFinished = totalTasksCompleted + totalTasksFailed + totalTasksCancelled;\n        if (totalTasksStarted > 0) { // Calculate rate based on started tasks\n             taskCompletionRate = (totalTasksCompleted / totalTasksStarted) * 100;\n        } else if (tasks.length > 0) { // If no tasks started, but some exist, rate is 0\n             taskCompletionRate = 0;\n        } else { // If no tasks at all, rate is N/A (or 100 if you consider 0/0 = 100)\n             taskCompletionRate = 100; // Or NaN, depending on desired representation\n        }\n\n\n        let runeExecutionSuccessRate = 0;\n        let totalRuneExecutions = 0;\n        let successfulRuneExecutions = 0;\n\n        // Filter user actions for rune executions\n        const runeExecutionActions = userActions.filter(action => action.type.startsWith('rune:execute:'));\n        totalRuneExecutions = runeExecutionActions.length;\n\n        // To determine success/failure, we check the 'rune_action_executed' vs 'rune_action_failed' events.\n        const successfulRuneEvents = systemEvents.filter(event => event.type === 'rune_action_executed');\n        const failedRuneEvents = systemEvents.filter(event => event.type === 'rune_action_failed');\n        successfulRuneExecutions = successfulRuneEvents.length;\n\n\n        if (totalRuneExecutions > 0) {\n            // Calculate rate based on events if available\n            const totalEvents = successfulRuneExecutions + failedRuneEvents.length;\n            if (totalEvents > 0) {\n                 runeExecutionSuccessRate = (successfulRuneExecutions / totalEvents) * 100;\n            } else {\n                 // If there were executions logged but no success/fail events, assume 0% success?\n                 // Or maybe this indicates a logging issue. For MVP, assume 0 if no events.\n                 runeExecutionSuccessRate = 0;\n            }\n        } else {\n             runeExecutionSuccessRate = 100; // Or NaN if no executions\n        }\n\n        // Calculate Error Rate (System Events with severity 'error')\n        const totalSystemEvents = systemEvents.length;\n        const errorEvents = systemEvents.filter(event => event.severity === 'error');\n        const systemErrorRate = totalSystemEvents > 0 ? (errorEvents.length / totalSystemEvents) * 100 : 0;\n\n\n        let averageTaskDuration = 0;\n        const completedTasksWithDuration = tasks.filter(task => task.status === 'completed' && task.start_timestamp && task.completion_timestamp);\n        if (completedTasksWithDuration.length > 0) {\n            const totalDuration = completedTasksWithDuration.reduce((sum, task) => {\n                const start = new Date(task.start_timestamp!).getTime();\n                const end = new Date(task.completion_timestamp!).getTime();\n                return sum + (end - start); // Duration in milliseconds\n            }, 0);\n            averageTaskDuration = (totalDuration / completedTasksWithDuration.length) / 1000; // Average duration in seconds\n        }\n\n\n        // Count Knowledge Records added within the timeframe\n        const knowledgeRecordsAdded = knowledgeRecords.length;\n\n\n        // Count Abilities Forged within the timeframe\n        const forgedAbilities = abilities.filter(ability => {\n            if (!ability.creation_timestamp) return false;\n            const creationTime = new Date(ability.creation_timestamp).getTime();\n            return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n\n\n        // Count Goals Created within the timeframe\n        const createdGoals = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n\n\n        // Calculate Goal Completion Rate (for goals created within timeframe)\n        const completedGoals = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             const createdWithinTimeframe = startDate ? creationTime >= startDate.getTime() : true;\n             return createdWithinTimeframe && goal.status === 'completed';\n        }).length;\n        const totalGoalsCreatedWithinTimeframe = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n        const goalCompletionRate = totalGoalsCreatedWithinTimeframe > 0 ? (completedGoals / totalGoalsCreatedWithinTimeframe) * 100 : 0;\n\n\n        // TODO: Calculate other KPIs (e.g., Automation Rate, Feature Usage)\n        // Automation Rate: Percentage of tasks/actions initiated by the system/abilities vs. manual user actions.\n        // Feature Usage: How often different runes, abilities, or core features are used.\n\n\n        const kpiResults = {\n            timeframe,\n            taskCompletionRate: taskCompletionRate.toFixed(2), // Format to 2 decimal places\n            totalTasksCompleted,\n            totalTasksFailed,\n            totalTasksCancelled,\n            totalTasksStarted,\n            runeExecutionSuccessRate: runeExecutionSuccessRate.toFixed(2), // Format to 2 decimal places\n            totalRuneExecutions,\n            successfulRuneExecutions,\n            systemErrorRate: systemErrorRate.toFixed(2), // Format to 2 decimal places\n            averageTaskDuration: averageTaskDuration.toFixed(2), // in seconds, format to 2 decimal places\n            knowledgeRecordsAdded,\n            forgedAbilities, // Added forged abilities count\n            createdGoals, // Added created goals count\n            goalCompletionRate: goalCompletionRate.toFixed(2), // Format to 2 decimal places\n            // Add other calculated KPIs\n        };\n\n        console.log("], [", { userId, timeframe });\n\n        if (!userId) {\n            console.error('[AnalyticsService] Cannot calculate KPIs: User ID is required.');\n            this.context.loggingService?.logError('Cannot calculate KPIs: User ID is required.');\n            throw new Error('User ID is required to calculate KPIs.');\n        }\n\n        // Collect the necessary raw data for the specified timeframe\n        const rawData = await this.collectRawData(userId, timeframe);\n        const { userActions, tasks, systemEvents, runes, abilities, goals, knowledgeRecords } = rawData; // Destructure relevant data\n\n\n        // --- Calculate KPIs ---\n        let taskCompletionRate = 0;\n        let totalTasksCompleted = 0;\n        let totalTasksFailed = 0;\n        let totalTasksCancelled = 0;\n        let totalTasksStarted = 0; // Tasks that reached 'in-progress' status\n\n        tasks.forEach(task => {\n            if (task.status === 'completed') totalTasksCompleted++;\n            if (task.status === 'failed') totalTasksFailed++;\n            if (task.status === 'cancelled') totalTasksCancelled++;\n            if (task.start_timestamp) totalTasksStarted++; // Count tasks that were started\n        });\n\n        const totalTasksFinished = totalTasksCompleted + totalTasksFailed + totalTasksCancelled;\n        if (totalTasksStarted > 0) { // Calculate rate based on started tasks\n             taskCompletionRate = (totalTasksCompleted / totalTasksStarted) * 100;\n        } else if (tasks.length > 0) { // If no tasks started, but some exist, rate is 0\n             taskCompletionRate = 0;\n        } else { // If no tasks at all, rate is N/A (or 100 if you consider 0/0 = 100)\n             taskCompletionRate = 100; // Or NaN, depending on desired representation\n        }\n\n\n        let runeExecutionSuccessRate = 0;\n        let totalRuneExecutions = 0;\n        let successfulRuneExecutions = 0;\n\n        // Filter user actions for rune executions\n        const runeExecutionActions = userActions.filter(action => action.type.startsWith('rune:execute:'));\n        totalRuneExecutions = runeExecutionActions.length;\n\n        // To determine success/failure, we check the 'rune_action_executed' vs 'rune_action_failed' events.\n        const successfulRuneEvents = systemEvents.filter(event => event.type === 'rune_action_executed');\n        const failedRuneEvents = systemEvents.filter(event => event.type === 'rune_action_failed');\n        successfulRuneExecutions = successfulRuneEvents.length;\n\n\n        if (totalRuneExecutions > 0) {\n            // Calculate rate based on events if available\n            const totalEvents = successfulRuneExecutions + failedRuneEvents.length;\n            if (totalEvents > 0) {\n                 runeExecutionSuccessRate = (successfulRuneExecutions / totalEvents) * 100;\n            } else {\n                 // If there were executions logged but no success/fail events, assume 0% success?\n                 // Or maybe this indicates a logging issue. For MVP, assume 0 if no events.\n                 runeExecutionSuccessRate = 0;\n            }\n        } else {\n             runeExecutionSuccessRate = 100; // Or NaN if no executions\n        }\n\n        // Calculate Error Rate (System Events with severity 'error')\n        const totalSystemEvents = systemEvents.length;\n        const errorEvents = systemEvents.filter(event => event.severity === 'error');\n        const systemErrorRate = totalSystemEvents > 0 ? (errorEvents.length / totalSystemEvents) * 100 : 0;\n\n\n        let averageTaskDuration = 0;\n        const completedTasksWithDuration = tasks.filter(task => task.status === 'completed' && task.start_timestamp && task.completion_timestamp);\n        if (completedTasksWithDuration.length > 0) {\n            const totalDuration = completedTasksWithDuration.reduce((sum, task) => {\n                const start = new Date(task.start_timestamp!).getTime();\n                const end = new Date(task.completion_timestamp!).getTime();\n                return sum + (end - start); // Duration in milliseconds\n            }, 0);\n            averageTaskDuration = (totalDuration / completedTasksWithDuration.length) / 1000; // Average duration in seconds\n        }\n\n\n        // Count Knowledge Records added within the timeframe\n        const knowledgeRecordsAdded = knowledgeRecords.length;\n\n\n        // Count Abilities Forged within the timeframe\n        const forgedAbilities = abilities.filter(ability => {\n            if (!ability.creation_timestamp) return false;\n            const creationTime = new Date(ability.creation_timestamp).getTime();\n            return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n\n\n        // Count Goals Created within the timeframe\n        const createdGoals = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n\n\n        // Calculate Goal Completion Rate (for goals created within timeframe)\n        const completedGoals = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             const createdWithinTimeframe = startDate ? creationTime >= startDate.getTime() : true;\n             return createdWithinTimeframe && goal.status === 'completed';\n        }).length;\n        const totalGoalsCreatedWithinTimeframe = goals.filter(goal => {\n             if (!goal.creation_timestamp) return false;\n             const creationTime = new Date(goal.creation_timestamp).getTime();\n             return startDate ? creationTime >= startDate.getTime() : true;\n        }).length;\n        const goalCompletionRate = totalGoalsCreatedWithinTimeframe > 0 ? (completedGoals / totalGoalsCreatedWithinTimeframe) * 100 : 0;\n\n\n        // TODO: Calculate other KPIs (e.g., Automation Rate, Feature Usage)\n        // Automation Rate: Percentage of tasks/actions initiated by the system/abilities vs. manual user actions.\n        // Feature Usage: How often different runes, abilities, or core features are used.\n\n\n        const kpiResults = {\n            timeframe,\n            taskCompletionRate: taskCompletionRate.toFixed(2), // Format to 2 decimal places\n            totalTasksCompleted,\n            totalTasksFailed,\n            totalTasksCancelled,\n            totalTasksStarted,\n            runeExecutionSuccessRate: runeExecutionSuccessRate.toFixed(2), // Format to 2 decimal places\n            totalRuneExecutions,\n            successfulRuneExecutions,\n            systemErrorRate: systemErrorRate.toFixed(2), // Format to 2 decimal places\n            averageTaskDuration: averageTaskDuration.toFixed(2), // in seconds, format to 2 decimal places\n            knowledgeRecordsAdded,\n            forgedAbilities, // Added forged abilities count\n            createdGoals, // Added created goals count\n            goalCompletionRate: goalCompletionRate.toFixed(2), // Format to 2 decimal places\n            // Add other calculated KPIs\n        };\n\n        console.log("]))[AnalyticsService])
    KPI;
calculation;
complete;
for (user; ; )
    : $;
{
    userId;
}
", kpiResults);\n        this.context.loggingService?.logInfo(";
KPI;
calculation;
complete;
for (user; $; { userId: userId }(__makeTemplateObject([", { userId, timeframe, kpis: kpiResults });\n\n        // TODO: Persist KPI snapshots for historical tracking (Supports Monitor)\n\n        return kpiResults;\n    }\n\n\n    /**\n     * Provides data and insights to the Evolution Engine for pattern identification and suggestions.\n     * Part of the \"Observe\" step, feeding into \"Learn\" and \"Generate\".\n     * @param userId The user ID. Required.\n     * @param timeframe Optional timeframe. Defaults to 'all'.\n     * @returns Promise<any> Data structured for the Evolution Engine.\n     */\n    async getDataForEvolution(userId: string, timeframe: 'day' | 'week' | 'month' | 'all' = 'all'): Promise<any> {\n        console.log("], [", { userId, timeframe, kpis: kpiResults });\n\n        // TODO: Persist KPI snapshots for historical tracking (Supports Monitor)\n\n        return kpiResults;\n    }\n\n\n    /**\n     * Provides data and insights to the Evolution Engine for pattern identification and suggestions.\n     * Part of the \\\"Observe\\\" step, feeding into \\\"Learn\\\" and \\\"Generate\\\".\n     * @param userId The user ID. Required.\n     * @param timeframe Optional timeframe. Defaults to 'all'.\n     * @returns Promise<any> Data structured for the Evolution Engine.\n     */\n    async getDataForEvolution(userId: string, timeframe: 'day' | 'week' | 'month' | 'all' = 'all'): Promise<any> {\n        console.log("]))[AnalyticsService])
    Providing;
data;
for (Evolution; Engine; )
    for (user; ; )
        : $;
{
    userId;
}
timeframe: $;
{
    timeframe;
}
");\n        this.context.loggingService?.logInfo(";
Providing;
data;
for (Evolution; Engine; )
    for (user; $; { userId: userId }(__makeTemplateObject([", { userId, timeframe });\n\n        if (!userId) {\n            console.error('[AnalyticsService] Cannot provide data for evolution: User ID is required.');\n            this.context.loggingService?.logError('Cannot provide data for evolution: User ID is required.');\n            throw new Error('User ID is required to provide data for evolution.');\n        }\n\n        // Collect raw data\n        const rawData = await this.collectRawData(userId, timeframe);\n        const { userActions, tasks, systemEvents, knowledgeRecords } = rawData; // Destructure relevant data\n\n\n        // --- Process Data for Evolution Engine ---\n        // Structure the data in a way that the Evolution Engine can easily consume\n        // This might involve:\n        // - Grouping user actions by type, sequence, or context.\n        // - Summarizing task outcomes (success/failure rates per task type or action type).\n        // - Identifying frequent events or event sequences.\n        // - Extracting keywords or topics from knowledge records or logs.\n\n        // For MVP, just return the raw data or slightly processed versions\n        const processedData = {\n            recentUserActions: userActions, // Evolution Engine can analyze sequences/frequency\n            failedTasks: tasks.filter(task => task.status === 'failed'), // Evolution Engine can diagnose failures\n            recentSystemEvents: systemEvents, // Evolution Engine can analyze event patterns\n            recentKnowledgeRecords: knowledgeRecords, // Evolution Engine can analyze content/sources\n            // TODO: Add other processed data (e.g., frequent action sequences, task step success rates, event patterns)\n            // Example: processActionSequences(actions: UserAction[]): { sequence: string[], count: number }[]\n            // Example: processTaskStepOutcomes(tasks: Task[]): { actionType: string, successRate: number }[]\n            // Example: processEventFrequency(systemEvents: SystemEvent[]): { eventType: string, count: number }[]\n        };\n\n        console.log("], [", { userId, timeframe });\n\n        if (!userId) {\n            console.error('[AnalyticsService] Cannot provide data for evolution: User ID is required.');\n            this.context.loggingService?.logError('Cannot provide data for evolution: User ID is required.');\n            throw new Error('User ID is required to provide data for evolution.');\n        }\n\n        // Collect raw data\n        const rawData = await this.collectRawData(userId, timeframe);\n        const { userActions, tasks, systemEvents, knowledgeRecords } = rawData; // Destructure relevant data\n\n\n        // --- Process Data for Evolution Engine ---\n        // Structure the data in a way that the Evolution Engine can easily consume\n        // This might involve:\n        // - Grouping user actions by type, sequence, or context.\n        // - Summarizing task outcomes (success/failure rates per task type or action type).\n        // - Identifying frequent events or event sequences.\n        // - Extracting keywords or topics from knowledge records or logs.\n\n        // For MVP, just return the raw data or slightly processed versions\n        const processedData = {\n            recentUserActions: userActions, // Evolution Engine can analyze sequences/frequency\n            failedTasks: tasks.filter(task => task.status === 'failed'), // Evolution Engine can diagnose failures\n            recentSystemEvents: systemEvents, // Evolution Engine can analyze event patterns\n            recentKnowledgeRecords: knowledgeRecords, // Evolution Engine can analyze content/sources\n            // TODO: Add other processed data (e.g., frequent action sequences, task step success rates, event patterns)\n            // Example: processActionSequences(actions: UserAction[]): { sequence: string[], count: number }[]\n            // Example: processTaskStepOutcomes(tasks: Task[]): { actionType: string, successRate: number }[]\n            // Example: processEventFrequency(systemEvents: SystemEvent[]): { eventType: string, count: number }[]\n        };\n\n        console.log("]))[AnalyticsService])
        Data;
prepared;
for (Evolution; Engine; )
    for (user; ; )
        : $;
{
    userId;
}
");\n        this.context.loggingService?.logInfo(";
Data;
prepared;
for (Evolution; Engine; )
    for (user; $; { userId: userId }(__makeTemplateObject([", { userId, timeframe });\n\n        return processedData;\n    }\n\n\n    // TODO: Implement methods for processing raw data into structured formats for Evolution Engine.\n    // Example: processActionSequences(actions: UserAction[]): { sequence: string[], count: number }[]\n    // Example: processTaskStepOutcomes(tasks: Task[]): { actionType: string, successRate: number }[]\n    // TODO: Implement methods for tracking specific user journeys or workflows.\n    // TODO: Implement methods for generating reports or visualizations (integrates with UI).    // TODO: This module is the core of the Analytics Service (\u5206\u6790\u670D\u52D9) and supports Observe (\u89C0\u5BDF) and Monitor (\u76E3\u63A7) in the Six Styles.    // TODO: Data collected and processed here feeds directly into the Evolution Engine (\u7120\u9650\u9032\u5316\u5FAA\u74B0).}// Example Usage (called by EvolutionEngine, UI, or background processes):\\// const analyticsService = new AnalyticsService(systemContext);\\// const kpis = await analyticsService.calculateKPIs('month', 'user-sim-123');\\// console.log('Monthly KPIs:', kpis);\\// const evolutionData = await analyticsService.getDataForEvolution('week', 'user-sim-123');\\// console.log('Data for Evolution Engine:', evolutionData);\\"], [", { userId, timeframe });\n\n        return processedData;\n    }\n\n\n    // TODO: Implement methods for processing raw data into structured formats for Evolution Engine.\n    // Example: processActionSequences(actions: UserAction[]): { sequence: string[], count: number }[]\n    // Example: processTaskStepOutcomes(tasks: Task[]): { actionType: string, successRate: number }[]\n    // TODO: Implement methods for tracking specific user journeys or workflows.\n    // TODO: Implement methods for generating reports or visualizations (integrates with UI).\\\n    // TODO: This module is the core of the Analytics Service (\\u5206\\u6790\\u670d\\u52d9) and supports Observe (\\u89c0\\u5bdf) and Monitor (\\u76e3\\u63a7) in the Six Styles.\\\n    // TODO: Data collected and processed here feeds directly into the Evolution Engine (\\u7120\\u9650\\u9032\\u5316\\u5faa\\u74b0).\\\n}\\\n\\\n// Example Usage (called by EvolutionEngine, UI, or background processes):\\\\\\\n// const analyticsService = new AnalyticsService(systemContext);\\\\\\\n// const kpis = await analyticsService.calculateKPIs('month', 'user-sim-123');\\\\\\\n// console.log('Monthly KPIs:', kpis);\\\\\\\n// const evolutionData = await analyticsService.getDataForEvolution('week', 'user-sim-123');\\\\\\\n// console.log('Data for Evolution Engine:', evolutionData);\\\\\\\n"]))(__makeTemplateObject([""], [""])))
        ;
