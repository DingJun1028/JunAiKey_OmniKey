"use strict";
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
Object.defineProperty(exports, "__esModule", { value: true });
""(templateObject_1 || (templateObject_1 = __makeTemplateObject(["typescript\n// src/components/KnowledgeGraphViewer.tsx\n// \u53EF\u91CD\u7528\u7D44\u4EF6 (Reusable Component) - \u77E5\u8B58\u5716\u8B5C\u67E5\u770B\u5668 (Knowledge Graph Viewer)\n// Displays a knowledge graph using React Flow.\n// --- New: Enhance node and edge styling --\n// --- New: Add basic node click interaction (show details) --\n// --- Modified: Implement node click to show details in a sidebar/modal --\n// --- New: Add filtering by source --\n\nimport React, { useEffect, useState, useCallback } from 'react'; // Import useCallback\nimport ReactFlow, {\n  MiniMap,\n  Controls,\n  Background,\n  Node,\n  Edge,\n  Position,\n  ReactFlowProvider,\n  useNodesState,\n  useEdgesState,\n  OnNodesChange, // Import OnNodesChange type\n  OnEdgesChange, // Import OnEdgesChange type\n  NodeMouseHandler, // Import NodeMouseHandler type\n} from 'reactflow';\nimport 'reactflow/dist/style.css'; // Import React Flow styles\nimport dagre from '@reactflow/dagre'; // Import Dagre layout algorithm\nimport { KnowledgeRecord, KnowledgeRelation } from '../interfaces'; // Import interfaces\nimport { XCircle } from 'lucide-react'; // Import XCircle icon for closing modal\nimport ReactMarkdown from 'react-markdown'; // For rendering markdown\n\n// Access core modules from the global window object (for MVP simplicity)\ndeclare const window: any;\nconst knowledgeGraphService: any = window.systemContext?.knowledgeGraphService; // Access KnowledgeGraphService\nconst systemContext: any = window.systemContext; // Access the full context for currentUser\n\n\n// --- New: Initialize Dagre graph ---\nconst dagreGraph = new dagre.graphlib.Graph();\ndagreGraph.setDefaultEdgeLabel(() => ({}));\n\n// Define node and edge dimensions for layout calculation\nconst nodeWidth = 200; // Approximate width of the node label div\nconst nodeHeight = 80; // Approximate height of the node label div (adjust based on content)\n// --- End New ---\n\n\n// Define the props for the KnowledgeGraphViewer component\ninterface KnowledgeGraphViewerProps {\n    userId: string; // The user ID whose graph to display\n    sourceFilter?: string; // New: Add source filter prop\n    // TODO: Add filters (e.g., by relation type, timeframe)\n}\n\n\n// --- New: Custom Node Component for Graph Viewer ---\n// This component will render the content of each node in the React Flow graph.\n// It should display node details and indicate execution status.\nconst GraphNode: React.FC<{ data: { label: string, knowledgeRecord: KnowledgeRecord } }> = ({ data }) => {\n    const { label, knowledgeRecord } = data;\n\n    // Determine border color based on source (example)\n    const borderColor = knowledgeRecord.source === 'dev-log' ? 'border-orange-500' :\n                        knowledgeRecord.source === 'dev-conversation' ? 'border-blue-500' :\n                        'border-neutral-500'; // Default border\n\n    return (\n        <div className={"], ["typescript\n// src/components/KnowledgeGraphViewer.tsx\n// \\u53ef\\u91cd\\u7528\\u7d44\\u4ef6 (Reusable Component) - \\u77e5\\u8b58\\u5716\\u8b5c\\u67e5\\u770b\\u5668 (Knowledge Graph Viewer)\n// Displays a knowledge graph using React Flow.\n// --- New: Enhance node and edge styling --\n// --- New: Add basic node click interaction (show details) --\n// --- Modified: Implement node click to show details in a sidebar/modal --\n// --- New: Add filtering by source --\n\nimport React, { useEffect, useState, useCallback } from 'react'; // Import useCallback\nimport ReactFlow, {\n  MiniMap,\n  Controls,\n  Background,\n  Node,\n  Edge,\n  Position,\n  ReactFlowProvider,\n  useNodesState,\n  useEdgesState,\n  OnNodesChange, // Import OnNodesChange type\n  OnEdgesChange, // Import OnEdgesChange type\n  NodeMouseHandler, // Import NodeMouseHandler type\n} from 'reactflow';\nimport 'reactflow/dist/style.css'; // Import React Flow styles\nimport dagre from '@reactflow/dagre'; // Import Dagre layout algorithm\nimport { KnowledgeRecord, KnowledgeRelation } from '../interfaces'; // Import interfaces\nimport { XCircle } from 'lucide-react'; // Import XCircle icon for closing modal\nimport ReactMarkdown from 'react-markdown'; // For rendering markdown\n\n// Access core modules from the global window object (for MVP simplicity)\ndeclare const window: any;\nconst knowledgeGraphService: any = window.systemContext?.knowledgeGraphService; // Access KnowledgeGraphService\nconst systemContext: any = window.systemContext; // Access the full context for currentUser\n\n\n// --- New: Initialize Dagre graph ---\nconst dagreGraph = new dagre.graphlib.Graph();\ndagreGraph.setDefaultEdgeLabel(() => ({}));\n\n// Define node and edge dimensions for layout calculation\nconst nodeWidth = 200; // Approximate width of the node label div\nconst nodeHeight = 80; // Approximate height of the node label div (adjust based on content)\n// --- End New ---\n\n\n// Define the props for the KnowledgeGraphViewer component\ninterface KnowledgeGraphViewerProps {\n    userId: string; // The user ID whose graph to display\n    sourceFilter?: string; // New: Add source filter prop\n    // TODO: Add filters (e.g., by relation type, timeframe)\n}\n\n\n// --- New: Custom Node Component for Graph Viewer ---\n// This component will render the content of each node in the React Flow graph.\n// It should display node details and indicate execution status.\nconst GraphNode: React.FC<{ data: { label: string, knowledgeRecord: KnowledgeRecord } }> = ({ data }) => {\n    const { label, knowledgeRecord } = data;\n\n    // Determine border color based on source (example)\n    const borderColor = knowledgeRecord.source === 'dev-log' ? 'border-orange-500' :\n                        knowledgeRecord.source === 'dev-conversation' ? 'border-blue-500' :\n                        'border-neutral-500'; // Default border\n\n    return (\n        <div className={"])));
p - 2;
rounded - md;
border - l - 4;
$;
{
    borderColor;
}
bg - neutral - 700 / 70;
shadow - md;
w - [$, { nodeWidth: nodeWidth }, px];
h - [$, { nodeHeight: nodeHeight }, px];
overflow - hidden;
text - ellipsis;
whitespace - nowrap;
flex;
flex - col(templateObject_2 || (templateObject_2 = __makeTemplateObject(["}>\n            <div className=\"text-sm font-semibold text-neutral-200 overflow-hidden text-ellipsis whitespace-nowrap\">\n                Q: {knowledgeRecord.question}\n            </div>\n            <div className=\"text-neutral-400 text-xs mt-1 overflow-hidden text-ellipsis whitespace-nowrap\">\n                A: {knowledgeRecord.answer}\n            </div>\n            {/* Add more details like source, tags if needed */}\n            {knowledgeRecord.source && <span className=\"text-neutral-400 text-xs mt-1\">Source: {knowledgeRecord.source}</span>}\n        </div>\n    );\n};\n\n// Define custom node types for the graph viewer\nconst nodeTypes: NodeTypes = {\n    default: GraphNode, // Use our custom component for the default type\n};\n// --- End New ---\n\n\nconst KnowledgeGraphViewer: React.FC<KnowledgeGraphViewerProps> = ({ userId, sourceFilter }) => { // Accept sourceFilter prop\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesState] = useEdgesState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  // --- New: State for selected node details --\n  const [selectedNodeDetails, setSelectedNodeDetails] = useState<KnowledgeRecord | null>(null);\n  // --- End New ---\n\n\n  // --- New: Layout function using Dagre ---\n  const getLayoutedElements = useCallback(\n      (nodes: Node[], edges: Edge[], direction = 'TB') => {\n          const isHorizontal = direction === 'LR';\n          dagreGraph.setGraph({ rankdir: direction });\n\n          nodes.forEach((node) => {\n              // Set nodes with dimensions for layout calculation\n              dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });\n          });\n\n          edges.forEach((edge) => {\n              dagreGraph.setEdge(edge.source, edge.target);\n          });\n\n          dagre.layout(dagreGraph);\n\n          const layoutedNodes = nodes.map((node) => {\n              const nodeWithPosition = dagreGraph.node(node.id);\n              // We need to pass a node object with at least position.\n              // Node is passed by reference, so we modify it directly.\n              node.position = {\n                  x: nodeWithPosition.x - nodeWidth / 2,\n                  y: nodeWithPosition.y - nodeHeight / 2,\n              };\n\n              return node;\n          });\n\n          return { nodes: layoutedNodes, edges }; // Return edges as is, layout only affects nodes\n      },\n      [] // Dependencies for useCallback - empty as it only depends on imported constants/libraries\n  );\n  // --- End New ---\n\n\n  // --- New: Convert Knowledge Data to React Flow format with Layout ---\n  const knowledgeToReactFlowData = useCallback((knowledgeNodes: KnowledgeRecord[], knowledgeEdges: KnowledgeRelation[]) => {\n      const reactFlowNodes: Node[] = knowledgeNodes.map((node) => {\n          return {\n              id: node.id, // Use KnowledgeRecord ID as React Flow node ID\n              // Position will be calculated by the layout algorithm\n              position: { x: 0, y: 0 }, // Placeholder position\n              data: {\n                  label: (\n                      <div className=\"p-2 bg-neutral-700/70 rounded-md border border-neutral-600 text-neutral-200 text-xs w-[180px] overflow-hidden text-ellipsis whitespace-nowrap\">\n                          <div className=\"font-semibold overflow-hidden text-ellipsis whitespace-nowrap\">Q: {node.question}</div>\n                          <div className=\"text-neutral-400 mt-1 overflow-hidden text-ellipsis whitespace-nowrap\">A: {node.answer}</div>\n                          {/* Add more details like source, tags if needed */}\n                      </div>\n                  ),\n                  // Store the full knowledge record in data for easy access on click\n                  knowledgeRecord: node,\n              },\n              type: 'default', // Use our custom node type\n              sourcePosition: Position.Bottom, // Default source handle position\n              targetPosition: Position.Top, // Default target handle position\n              style: {\n                  padding: 0, // Remove default padding as label has its own\n                  backgroundColor: 'transparent', // Make node background transparent\n                  width: nodeWidth, // Set width for layout calculation\n                  height: nodeHeight, // Set height for layout calculation\n                  border: 'none', // No border on the container, let the custom node handle it\n              },\n          };\n      });\n\n      const reactFlowEdges: Edge[] = knowledgeEdges.map(edge => {\n          return {\n              id: edge.id, // Use KnowledgeRelation ID as React Flow edge ID\n              source: edge.source_record_id,\n              target: edge.target_record_id,\n              type: 'default', // Use default edge type\n              label: edge.relation_type, // Show relation type as label\n              style: { strokeWidth: 1, stroke: '#999' },\n              // animated: true, // Optional: animate edges\n          };\n      });\n\n      // Apply layout algorithm\n      const layouted = getLayoutedElements(reactFlowNodes, reactFlowEdges, 'TB'); // Use 'TB' for top-to-bottom layout\n\n      return { nodes: layouted.nodes, edges: layouted.edges };\n  }, [getLayoutedElements]); // Re-generate React Flow data if layout function changes\n\n\n  const fetchGraphData = useCallback(async () => {\n       if (!knowledgeGraphService || !userId) {\n            setError(\"KnowledgeGraphService module not initialized or user ID is missing.\");\n            setLoading(false);\n            return;\n        }\n      setLoading(true);\n      setError(null);\n      try {\n          // Fetch graph data for the current user\n          const graphData = await knowledgeGraphService.getGraphData(userId); // Pass user ID\n          console.log('Fetched graph data:', graphData);\n\n          // --- New: Apply source filter ---\n          const filteredNodes = sourceFilter\n              ? graphData.nodes.filter((node: KnowledgeRecord) => node.source === sourceFilter)\n              : graphData.nodes;\n\n          // Filter edges to only include those connecting the filtered nodes\n          const filteredNodeIds = new Set(filteredNodes.map((node: KnowledgeRecord) => node.id));\n          const filteredEdges = graphData.edges.filter((edge: KnowledgeRelation) =>\n              filteredNodeIds.has(edge.source_record_id) && filteredNodeIds.has(edge.target_record_id)\n          );\n          // --- End New ---\n\n          // Convert filtered data to React Flow format and apply layout\n          const reactFlowData = knowledgeToReactFlowData(filteredNodes, filteredEdges); // Use filtered data\n\n          setNodes(reactFlowData.nodes);\n          setEdges(reactFlowData.edges);\n\n      } catch (err: any) {\n          console.error('Error fetching graph data:', err);\n          setError("], ["}>\n            <div className=\"text-sm font-semibold text-neutral-200 overflow-hidden text-ellipsis whitespace-nowrap\">\n                Q: {knowledgeRecord.question}\n            </div>\n            <div className=\"text-neutral-400 text-xs mt-1 overflow-hidden text-ellipsis whitespace-nowrap\">\n                A: {knowledgeRecord.answer}\n            </div>\n            {/* Add more details like source, tags if needed */}\n            {knowledgeRecord.source && <span className=\"text-neutral-400 text-xs mt-1\">Source: {knowledgeRecord.source}</span>}\n        </div>\n    );\n};\n\n// Define custom node types for the graph viewer\nconst nodeTypes: NodeTypes = {\n    default: GraphNode, // Use our custom component for the default type\n};\n// --- End New ---\n\n\nconst KnowledgeGraphViewer: React.FC<KnowledgeGraphViewerProps> = ({ userId, sourceFilter }) => { // Accept sourceFilter prop\n  const [nodes, setNodes, onNodesChange] = useNodesState([]);\n  const [edges, setEdges, onEdgesState] = useEdgesState([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  // --- New: State for selected node details --\n  const [selectedNodeDetails, setSelectedNodeDetails] = useState<KnowledgeRecord | null>(null);\n  // --- End New ---\n\n\n  // --- New: Layout function using Dagre ---\n  const getLayoutedElements = useCallback(\n      (nodes: Node[], edges: Edge[], direction = 'TB') => {\n          const isHorizontal = direction === 'LR';\n          dagreGraph.setGraph({ rankdir: direction });\n\n          nodes.forEach((node) => {\n              // Set nodes with dimensions for layout calculation\n              dagreGraph.setNode(node.id, { width: nodeWidth, height: nodeHeight });\n          });\n\n          edges.forEach((edge) => {\n              dagreGraph.setEdge(edge.source, edge.target);\n          });\n\n          dagre.layout(dagreGraph);\n\n          const layoutedNodes = nodes.map((node) => {\n              const nodeWithPosition = dagreGraph.node(node.id);\n              // We need to pass a node object with at least position.\n              // Node is passed by reference, so we modify it directly.\n              node.position = {\n                  x: nodeWithPosition.x - nodeWidth / 2,\n                  y: nodeWithPosition.y - nodeHeight / 2,\n              };\n\n              return node;\n          });\n\n          return { nodes: layoutedNodes, edges }; // Return edges as is, layout only affects nodes\n      },\n      [] // Dependencies for useCallback - empty as it only depends on imported constants/libraries\n  );\n  // --- End New ---\n\n\n  // --- New: Convert Knowledge Data to React Flow format with Layout ---\n  const knowledgeToReactFlowData = useCallback((knowledgeNodes: KnowledgeRecord[], knowledgeEdges: KnowledgeRelation[]) => {\n      const reactFlowNodes: Node[] = knowledgeNodes.map((node) => {\n          return {\n              id: node.id, // Use KnowledgeRecord ID as React Flow node ID\n              // Position will be calculated by the layout algorithm\n              position: { x: 0, y: 0 }, // Placeholder position\n              data: {\n                  label: (\n                      <div className=\"p-2 bg-neutral-700/70 rounded-md border border-neutral-600 text-neutral-200 text-xs w-[180px] overflow-hidden text-ellipsis whitespace-nowrap\">\n                          <div className=\"font-semibold overflow-hidden text-ellipsis whitespace-nowrap\">Q: {node.question}</div>\n                          <div className=\"text-neutral-400 mt-1 overflow-hidden text-ellipsis whitespace-nowrap\">A: {node.answer}</div>\n                          {/* Add more details like source, tags if needed */}\n                      </div>\n                  ),\n                  // Store the full knowledge record in data for easy access on click\n                  knowledgeRecord: node,\n              },\n              type: 'default', // Use our custom node type\n              sourcePosition: Position.Bottom, // Default source handle position\n              targetPosition: Position.Top, // Default target handle position\n              style: {\n                  padding: 0, // Remove default padding as label has its own\n                  backgroundColor: 'transparent', // Make node background transparent\n                  width: nodeWidth, // Set width for layout calculation\n                  height: nodeHeight, // Set height for layout calculation\n                  border: 'none', // No border on the container, let the custom node handle it\n              },\n          };\n      });\n\n      const reactFlowEdges: Edge[] = knowledgeEdges.map(edge => {\n          return {\n              id: edge.id, // Use KnowledgeRelation ID as React Flow edge ID\n              source: edge.source_record_id,\n              target: edge.target_record_id,\n              type: 'default', // Use default edge type\n              label: edge.relation_type, // Show relation type as label\n              style: { strokeWidth: 1, stroke: '#999' },\n              // animated: true, // Optional: animate edges\n          };\n      });\n\n      // Apply layout algorithm\n      const layouted = getLayoutedElements(reactFlowNodes, reactFlowEdges, 'TB'); // Use 'TB' for top-to-bottom layout\n\n      return { nodes: layouted.nodes, edges: layouted.edges };\n  }, [getLayoutedElements]); // Re-generate React Flow data if layout function changes\n\n\n  const fetchGraphData = useCallback(async () => {\n       if (!knowledgeGraphService || !userId) {\n            setError(\"KnowledgeGraphService module not initialized or user ID is missing.\");\n            setLoading(false);\n            return;\n        }\n      setLoading(true);\n      setError(null);\n      try {\n          // Fetch graph data for the current user\n          const graphData = await knowledgeGraphService.getGraphData(userId); // Pass user ID\n          console.log('Fetched graph data:', graphData);\n\n          // --- New: Apply source filter ---\n          const filteredNodes = sourceFilter\n              ? graphData.nodes.filter((node: KnowledgeRecord) => node.source === sourceFilter)\n              : graphData.nodes;\n\n          // Filter edges to only include those connecting the filtered nodes\n          const filteredNodeIds = new Set(filteredNodes.map((node: KnowledgeRecord) => node.id));\n          const filteredEdges = graphData.edges.filter((edge: KnowledgeRelation) =>\n              filteredNodeIds.has(edge.source_record_id) && filteredNodeIds.has(edge.target_record_id)\n          );\n          // --- End New ---\n\n          // Convert filtered data to React Flow format and apply layout\n          const reactFlowData = knowledgeToReactFlowData(filteredNodes, filteredEdges); // Use filtered data\n\n          setNodes(reactFlowData.nodes);\n          setEdges(reactFlowData.edges);\n\n      } catch (err: any) {\n          console.error('Error fetching graph data:', err);\n          setError("])));
Failed;
to;
load;
knowledge;
graph: $;
{
    err.message;
}
");\n      } finally {\n          setLoading(false);\n      }\n  }, [knowledgeGraphService, userId, knowledgeToReactFlowData, setNodes, setEdges, setLoading, setError, sourceFilter]); // Add sourceFilter to dependencies\n\n\n  useEffect(() => {\n    // Fetch graph data when the component mounts or when the user changes or sourceFilter changes\n    fetchGraphData();\n\n    // --- New: Subscribe to realtime updates for knowledge_records and knowledge_relations ---\n    // Note: KnowledgeGraphService itself subscribes to these updates and publishes events.\n    // We need to listen to those events here to update the graph visualization.\n    let unsubscribeRecordInsert: (() => void) | undefined;\n    let unsubscribeRecordUpdate: (() => void) | undefined;\n    let unsubscribeRecordDelete: (() => void) | undefined;\n    let unsubscribeRelationInsert: (() => void) | undefined;\n    let unsubscribeRelationUpdate: (() => void) | undefined;\n    let unsubscribeRelationDelete: (() => void) | undefined;\n\n    if (knowledgeGraphService?.context?.eventBus) { // Check if service and its EventBus are available\n        const eventBus = knowledgeGraphService.context.eventBus;\n\n        // Subscribe to knowledge record events\n        unsubscribeRecordInsert = eventBus.subscribe('knowledge_record_insert', (payload: KnowledgeRecord) => {\n            if (payload.user_id === userId) {\n                console.log('Graph Viewer received knowledge_record_insert event:', payload);\n                // Refetch graph data to include the new node\n                fetchGraphData();\n            }\n        });\n         unsubscribeRecordUpdate = eventBus.subscribe('knowledge_record_update', (payload: KnowledgeRecord) => {\n             if (payload.user_id === userId) {\n                 console.log('Graph Viewer received knowledge_record_update event:', payload);\n                 // Refetch graph data to update the node\n                 fetchGraphData();\n             }\n         });\n          unsubscribeRecordDelete = eventBus.subscribe('knowledge_record_delete', (payload: { id: string, userId: string }) => {\n             if (payload.userId === userId) {\n                 console.log('Graph Viewer received knowledge_record_delete event:', payload);\n                 // Refetch graph data to remove the node\n                 fetchGraphData();\n             }\n         });\n\n        // Subscribe to knowledge relation events\n        unsubscribeRelationInsert = eventBus.subscribe('knowledge_relation_insert', (payload: KnowledgeRelation) => {\n             if (payload.user_id === userId) {\n                 console.log('Graph Viewer received knowledge_relation_insert event:', payload);\n                 // Refetch graph data to include the new edge\n                 fetchGraphData();\n             }\n         });\n         unsubscribeRelationUpdate = eventBus.subscribe('knowledge_relation_update', (payload: KnowledgeRelation) => {\n             if (payload.user_id === userId) {\n                 console.log('Graph Viewer received knowledge_relation_update event:', payload);\n                 // Refetch graph data to update the edge\n                 fetchGraphData();\n             }\n         });\n          unsubscribeRelationDelete = eventBus.subscribe('knowledge_relation_delete', (payload: { relationId: string, userId: string }) => {\n             if (payload.userId === userId) {\n                 console.log('Graph Viewer received knowledge_relation_delete event:', payload);\n                 // Refetch graph data to remove the edge\n                 fetchGraphData();\n             }\n         });\n    }\n    // --- End New ---\n\n\n    return () => {\n        // Unsubscribe on component unmount\n        unsubscribeRecordInsert?.();\n        unsubscribeRecordUpdate?.();\n        unsubscribeRecordDelete?.();\n        unsubscribeRelationInsert?.();\n        unsubscribeRelationUpdate?.();\n        unsubscribeRelationDelete?.();\n    };\n\n  }, [fetchGraphData, userId, knowledgeGraphService]); // Re-run effect if fetchGraphData changes or user/service changes\n\n    // --- New: Handle Node Click to show details ---\n    const onNodeClick: NodeMouseHandler = useCallback((event, node) => {\n        console.log('Node clicked:', node);\n        // Find the full knowledge record from the node data\n        const record = node.data?.knowledgeRecord;\n        if (record) {\n            setSelectedNodeDetails(record);\n        } else {\n            setSelectedNodeDetails(null);\n        }\n    }, []);\n    // --- End New ---\n\n\n  if (loading) {\n    return <div className=\"text-neutral-400 text-center\">Loading knowledge graph...</div>;\n  }\n\n  if (error) {\n    return <div className=\"text-red-400 text-center\">Error loading knowledge graph: {error}</div>;\n  }\n\n  if (nodes.length === 0) {\n      return <div className=\"text-neutral-400 text-center\">No knowledge records found to build the graph{sourceFilter ? ";
for (source; ; )
    ;
"${sourceFilter}\"` : ''}.</div>; // Added filter info;
return (
// React Flow container - needs dimensions
<div className="relative" style={{ width: '100%', height: '500px', backgroundColor: '#282c34', borderRadius: '8px' }}> {/* Added relative positioning */}
        <ReactFlowProvider> {/* Wrap with provider */}
            <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} onEdgesChange={onEdgesState} onNodeClick={onNodeClick} // Add node click handler
 nodeTypes={nodeTypes} // Use custom node types
 
// onConnect={onConnect} // Enable if you want to allow drawing edges in the viewer
// onNodesDelete={onNodesDelete} // Enable if you want to allow deleting nodes
// onEdgesDelete={onEdgesDelete} // Enable if you want to allow deleting edges
fitView // Automatically fit the view to the nodes
 attributionPosition="bottom-left" 
// Enable interactive features for viewing
nodesDraggable={false} nodesConnectable={false} elementsSelectable={true} panOnDrag={true} zoomOnScroll={true}>
                <MiniMap />
                <Controls />
                <Background variant="dots" gap={12} size={1}/>
            </ReactFlow>
        </ReactFlowProvider> {/* End Provider */}

        {/* New: Node Details Modal/Sidebar */}
        {selectedNodeDetails && (<div className="absolute top-4 right-4 bg-neutral-800/90 p-4 rounded-lg shadow-xl max-w-sm max-h-[95%] overflow-y-auto scrollbar-thin scrollbar-thumb-neutral-700 z-10"> {/* Added absolute positioning and z-index */}
                <div className="flex justify-between items-center mb-3">
                    <h4 className="text-lg font-semibold text-blue-300">Node Details</h4>
                    <button onClick={function () { return setSelectedNodeDetails(null); }} className="text-neutral-400 hover:text-white"><XCircle size={20}/></button>
                </div>
                <div className="text-neutral-300 text-sm space-y-2">
                    <p><span className="font-semibold">ID:</span> {selectedNodeDetails.id}</p>
                    <p><span className="font-semibold">Question:</span> {selectedNodeDetails.question}</p>
                    {/* Render answer with Markdown */}
                    <div className="prose prose-invert max-w-none">
                         <span className="font-semibold">Answer:</span> <ReactMarkdown>{selectedNodeDetails.answer}</ReactMarkdown>
                    </div>
                    <p><span className="font-semibold">Created:</span> {new Date(selectedNodeDetails.timestamp).toLocaleString()}</p>
                    {selectedNodeDetails.source && <p><span className="font-semibold">Source:</span> {selectedNodeDetails.source}</p>}\\
                    {selectedNodeDetails.tags && selectedNodeDetails.tags.length > 0 && <p><span className="font-semibold">Tags:</span> {selectedNodeDetails.tags.join(', ')}</p>}\\
                    {/* TODO: Add buttons to view/edit the full record in the KB page */}\\
                </div>\\
            </div>)}\\
        )}\\
        {/* End New */}\\
\\
    </div>);
;
;
exports.default = KnowledgeGraphViewer;
""(templateObject_3 || (templateObject_3 = __makeTemplateObject([""], [""])));
var templateObject_1, templateObject_2, templateObject_3;
