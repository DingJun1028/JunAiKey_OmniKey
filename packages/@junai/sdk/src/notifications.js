var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var _a;
""(__makeTemplateObject(["typescript\n// packages/@junai/sdk/src/notifications.ts\n// Notification Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { Notification } from '../../../src/interfaces'; // Import interface from main project\n\nexport class NotificationClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Sends a notification to a user.\n   * @param notificationDetails The notification details (without id, timestamp, is_read). Must include userId, message, type, channel.\n   * @returns Promise<Notification> The created notification.\n   */\n  async send(notificationDetails: Omit<Notification, 'id' | 'timestamp' | 'is_read'>): Promise<Notification> {\n    // This assumes your API Gateway has an endpoint like POST /api/v1/notifications\n    // that delegates to the NotificationAgent/NotificationService.\n    // If calling directly to Supabase, use the Supabase client instead.\n\n    if (this.apiProxy.getApiEndpoint()) {\n        // Call custom API Gateway\n        const result = await this.apiProxy.callApi('/api/v1/notifications', 'POST', notificationDetails);\n        return result as Notification; // Assuming API returns the created notification\n    } else {\n        // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n        if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n             throw new Error('Supabase client not available in ApiProxy.');\n        }\n        // Direct Supabase insert for notifications\n        const { data, error } = await this.apiProxy['supabaseClient'].from('notifications').insert([notificationDetails]).select().single();\n        if (error) throw error;\n        return data as Notification;\n    }\n  }\n\n  /**\n   * Retrieves notifications for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., isRead, channel, limit).\n   * @returns Promise<Notification[]> An array of notifications.\n   */\n  async get(userId: string, options?: { isRead?: boolean, channel?: Notification['channel'], limit?: number }): Promise<Notification[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/notifications?userId=...&isRead=...&channel=...&limit=...\n     // that delegates to the NotificationAgent/NotificationService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/notifications', 'GET', undefined, { params: { userId, ...options } });\n         return result as Notification[]; // Assuming API returns an array of notifications\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('notifications').select('*').eq('user_id', userId);\n         if (options?.isRead !== undefined) {\n             query = query.eq('is_read', options.isRead);\n         }\n         if (options?.channel) {\n             query = query.eq('channel', options.channel);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as Notification[];\n     }\n  }\n\n  /**\n   * Marks a notification as read for a user.\n   * @param notificationId The ID of the notification. Required.\n   * @param userId The user ID. Required.\n   * @returns Promise<boolean> True if successful.\n   */\n  async markAsRead(notificationId: string, userId: string): Promise<boolean> {\n     // This assumes your API Gateway has an endpoint like PUT /api/v1/notifications/:notificationId/read\n     // that delegates to the NotificationAgent/NotificationService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         try {\n             const result = await this.apiProxy.callApi("], ["typescript\n// packages/@junai/sdk/src/notifications.ts\n// Notification Client Module for SDK\n\nimport { ApiProxy } from './apiProxy';\nimport { Notification } from '../../../src/interfaces'; // Import interface from main project\n\nexport class NotificationClient {\n  private apiProxy: ApiProxy;\n\n  constructor(apiProxy: ApiProxy) {\n    this.apiProxy = apiProxy;\n  }\n\n  /**\n   * Sends a notification to a user.\n   * @param notificationDetails The notification details (without id, timestamp, is_read). Must include userId, message, type, channel.\n   * @returns Promise<Notification> The created notification.\n   */\n  async send(notificationDetails: Omit<Notification, 'id' | 'timestamp' | 'is_read'>): Promise<Notification> {\n    // This assumes your API Gateway has an endpoint like POST /api/v1/notifications\n    // that delegates to the NotificationAgent/NotificationService.\n    // If calling directly to Supabase, use the Supabase client instead.\n\n    if (this.apiProxy.getApiEndpoint()) {\n        // Call custom API Gateway\n        const result = await this.apiProxy.callApi('/api/v1/notifications', 'POST', notificationDetails);\n        return result as Notification; // Assuming API returns the created notification\n    } else {\n        // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n        if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n             throw new Error('Supabase client not available in ApiProxy.');\n        }\n        // Direct Supabase insert for notifications\n        const { data, error } = await this.apiProxy['supabaseClient'].from('notifications').insert([notificationDetails]).select().single();\n        if (error) throw error;\n        return data as Notification;\n    }\n  }\n\n  /**\n   * Retrieves notifications for a user.\n   * @param userId The user ID. Required.\n   * @param options Optional filters (e.g., isRead, channel, limit).\n   * @returns Promise<Notification[]> An array of notifications.\n   */\n  async get(userId: string, options?: { isRead?: boolean, channel?: Notification['channel'], limit?: number }): Promise<Notification[]> {\n     // This assumes your API Gateway has an endpoint like GET /api/v1/notifications?userId=...&isRead=...&channel=...&limit=...\n     // that delegates to the NotificationAgent/NotificationService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         const result = await this.apiProxy.callApi('/api/v1/notifications', 'GET', undefined, { params: { userId, ...options } });\n         return result as Notification[]; // Assuming API returns an array of notifications\n     } else {\n         // Fallback to calling Supabase directly (requires user to be authenticated via SDK)\n         if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)\n              throw new Error('Supabase client not available in ApiProxy.');\n         }\n         // Direct Supabase query with filters\n         let query = this.apiProxy['supabaseClient'].from('notifications').select('*').eq('user_id', userId);\n         if (options?.isRead !== undefined) {\n             query = query.eq('is_read', options.isRead);\n         }\n         if (options?.channel) {\n             query = query.eq('channel', options.channel);\n         }\n         if (options?.limit) {\n             query = query.limit(options.limit);\n         }\n         query = query.order('timestamp', { ascending: false } as any);\n         const { data, error } = await query;\n         if (error) throw error;\n         return data as Notification[];\n     }\n  }\n\n  /**\n   * Marks a notification as read for a user.\n   * @param notificationId The ID of the notification. Required.\n   * @param userId The user ID. Required.\n   * @returns Promise<boolean> True if successful.\n   */\n  async markAsRead(notificationId: string, userId: string): Promise<boolean> {\n     // This assumes your API Gateway has an endpoint like PUT /api/v1/notifications/:notificationId/read\n     // that delegates to the NotificationAgent/NotificationService.\n     // If calling directly to Supabase, use the Supabase client instead.\n\n     if (this.apiProxy.getApiEndpoint()) {\n         // Call custom API Gateway\n         try {\n             const result = await this.apiProxy.callApi("])) / api / v1 / notifications / $;
{
    notificationId;
}
/read`, 'PUT', { userId };
;
return (result === null || result === void 0 ? void 0 : result.success) === true; // Assuming API returns { success: true } on success
try { }
catch (error) {
    // Assume 404 means not found/already read, other errors are failures
    if (((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) === 404)
        return false;
    throw error; // Re-throw other errors
}
{
    // Fallback to calling Supabase directly (requires user to be authenticated via SDK)
    if (!this.apiProxy['supabaseClient']) { // Access internal client (MVP)
        throw new Error('Supabase client not available in ApiProxy.');
    }
    // Direct Supabase update by ID (RLS should enforce ownership)
    var _b = await this.apiProxy['supabaseClient'].from('notifications').update({ is_read: true }).eq('id', notificationId).eq('user_id', userId).select('id', { count: 'exact' }), count = _b.count, error_1 = _b.error;
    if (error_1)
        throw error_1;
    return count !== null && count > 0;
}
""(__makeTemplateObject([""], [""]));
