var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/TemplateAgent.ts\n// \u7BC4\u672C\u4EE3\u7406\u4EBA (Template Agent) - Placeholder\n// Handles operations related to user-defined templates.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates template management logic.\n// --- Modified: Add operations for templates (create, get, update, delete) --\n// --- New: Add Realtime Updates for templates --\n// --- Modified: Update handleMessage to delegate to TemplateService --\n// --- Modified: Update handleMessage to use requestAgent for SupabaseAgent calls --\n\n\nimport { SystemContext, Template } from '../../interfaces'; // Assuming SystemContext interface exists, Import Template\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { TemplateService } from '../core/templates/TemplateService'; // Access via context\n// import { SupabaseAgent } from './SupabaseAgent'; // Access via requestAgent\n\n\nexport class TemplateAgent extends BaseAgent {\n    // private templateService: TemplateService; // Access via context\n    // private supabaseAgent: SupabaseAgent; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        super('template', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Template Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[TemplateAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events if needed\n\n        } catch (error) {\n            console.error('[TemplateAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Template Agent.\n     * Performs operations by delegating to the TemplateService.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\        console.log("], ["typescript\n// src/agents/TemplateAgent.ts\n// \\u7bc4\\u672c\\u4ee3\\u7406\\u4eba (Template Agent) - Placeholder\n// Handles operations related to user-defined templates.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates template management logic.\n// --- Modified: Add operations for templates (create, get, update, delete) --\n// --- New: Add Realtime Updates for templates --\n// --- Modified: Update handleMessage to delegate to TemplateService --\n// --- Modified: Update handleMessage to use requestAgent for SupabaseAgent calls --\n\n\nimport { SystemContext, Template } from '../../interfaces'; // Assuming SystemContext interface exists, Import Template\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { TemplateService } from '../core/templates/TemplateService'; // Access via context\n// import { SupabaseAgent } from './SupabaseAgent'; // Access via requestAgent\n\n\nexport class TemplateAgent extends BaseAgent {\n    // private templateService: TemplateService; // Access via context\n    // private supabaseAgent: SupabaseAgent; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        super('template', context);\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Template Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[TemplateAgent] Init completed.');\n\n            // TODO: Subscribe to relevant events if needed\n\n        } catch (error) {\n            console.error('[TemplateAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Template Agent.\n     * Performs operations by delegating to the TemplateService.\n     * @param message The message to handle. Expected payload varies by type.\n     * @returns Promise<AgentResponse> The response containing the result or error.\n     */\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\\\\\\n        console.log("]))[TemplateAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\\\\\n        const userId = this.context.currentUser?.id;\\        if (!userId) {\\             return { success: false, error: 'User not authenticated.' };\\        }\\\n\\\n        try {\\            let result: any;\\            switch (message.type) {\\                case 'create_template':\\                    // Payload: Omit<Template, 'id' | 'created_at' | 'updated_at'>\\                    if (!message.payload?.name || !message.payload?.type || message.payload?.content === undefined) {\\                         throw new Error('Name, type, and content are required to create template.');\\                    }\\                    // Ensure user_id is set from context if not provided in payload (payload might come from other agents)\\                    if (!message.payload.user_id) {\\                         message.payload.user_id = userId;\\                    }\\                    // Delegate to TemplateService\\                    result = await this.context.templateService?.createTemplate(message.payload, userId);\\                    if (!result) throw new Error('Failed to create template.');\\                    return { success: true, data: result };\\\\\n                case 'get_templates':\\                    // Payload: { typeFilter?: Template['type'], tagsFilter?: string[] }\\                    // Delegate to TemplateService\\                    result = await this.context.templateService?.getTemplates(userId, message.payload?.typeFilter, message.payload?.tagsFilter);\\                    return { success: true, data: result };\\\\\n                case 'get_template_by_id':\\                    // Payload: { templateId: string }\\                    if (!message.payload?.templateId) {\\                         throw new Error('Template ID is required.');\\                    }\\                    // Delegate to TemplateService\\                    result = await this.context.templateService?.getTemplateById(message.payload.templateId, userId);\\                    if (!result) return { success: false, error: 'Template not found or not accessible.' };\\                    return { success: true, data: result };\\\\\n                case 'update_template':\\                    // Payload: { templateId: string, updates: Partial<Omit<Template, 'id' | 'user_id' | 'created_at' | 'updated_at'>> }\\                    if (!message.payload?.templateId || !message.payload?.updates) {\\                         throw new Error('Template ID and updates are required to update template.');\\                    }\\                    // Delegate to TemplateService\\                    result = await this.context.templateService?.updateTemplate(\\\n                        message.payload.templateId,\\\n                        message.payload.updates,\\                        userId // Use userId from agent context\\                    );\\                    if (!result) return { success: false, error: 'Template not found or not owned by user.' };\\                    return { success: true, data: result };\\\\\n                case 'delete_template':\\                    // Payload: { templateId: string }\\                    if (!message.payload?.templateId) {\\                         throw new Error('Template ID is required to delete template.');\\                    }\\                    // Delegate to TemplateService\\                    result = await this.context.templateService?.deleteTemplate(message.payload.templateId, userId);\\                    if (!result) return { success: false, error: 'Template not found or not owned by user.' };\\                    return { success: true, data: { templateId: message.payload.templateId } }; // Return deleted ID\\\\\n\\\n                // TODO: Add cases for other Template operations (e.g., import_template, export_template, use_template)\\\\\n                default:\\                    console.warn("[TemplateAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");\\                    return { success: false, error: ";
Unknown;
message;
type;
for (TemplateAgent; ; )
    : $;
{
    message.type;
}
" };\\            }\\\n        } catch (error: any) {\\            console.error("[TemplateAgent];
Error;
handling;
message;
$;
{
    message.type;
}
", error);\\            return { success: false, error: error.message || 'An error occurred in TemplateAgent.' };\\        }\\\n    }\\\n\\\n    // TODO: Implement methods to send messages to other agents if needed\\    // e.g., sending a message to SelfNavigationAgent to create a task from a template\\}\\\n"(__makeTemplateObject([""], [""]));
