var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
""(__makeTemplateObject(["typescript\n// src/agents/KnowledgeAgent.ts\n// \u77E5\u8B58\u5EAB\u4EE3\u7406 (Knowledge Agent)\n// Handles operations related to the user's knowledge base.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates knowledge management logic.\n// --- Modified: Add handler for ingest_external_knowledge message --\n// --- Modified: Pass context parameter in query_knowledge message handling --\n// --- Modified: Update handleMessage to delegate to MemoryEngine/KnowledgeSync/KnowledgeGraph/Glossary --\n// --- Modified: Update handleMessage to use requestAgent for RuneEngraftingCenter calls --\n// --- Modified: Update handleMessage to delegate synthesize_knowledge to WisdomSecretArt --\n// --- Modified: Ensure consistent error handling and logging --\n\n\nimport { SystemContext, KnowledgeRecord, GlossaryTerm, KnowledgeCollection, KnowledgeRelation } from '../../interfaces'; // Assuming SystemContext interface exists, Import GlossaryTerm, KnowledgeCollection, KnowledgeRelation\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services/agents this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { MemoryEngine } from '../core/memory/MemoryEngine'; // Access via context\n// import { KnowledgeSync } from '../modules/knowledgeSync'; // Access via context\n// import { WisdomSecretArt } from '../core/wisdom/WisdomSecretArt'; // Access via requestAgent\n// import { GlossaryService } from '../core/glossary/GlossaryService'; // Access via context\n// import { KnowledgeGraphService } from '../core/wisdom/KnowledgeGraphService'; // Access via context\n// import { SacredRuneEngraver } from '../core/rune-engrafting/SacredRuneEngraver'; // Access via requestAgent\n\n\nexport class KnowledgeAgent extends BaseAgent { // Extend BaseAgent\n    // private memoryEngine: MemoryEngine; // Access via context\n    // private knowledgeSync: KnowledgeSync; // Access via context\n    // private wisdomSecretArt: WisdomSecretArt; // Access via requestAgent\n    // private glossaryService: GlossaryService; // Access via context\n    // private knowledgeGraphService: KnowledgeGraphService; // Access via context\n    // private sacredRuneEngraver: SacredRuneEngraver; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        // --- Modified: Call super constructor with agent name ---\n        super('knowledge', context); // Call BaseAgent constructor with agent name 'knowledge'\n        // --- End Modified ---\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Knowledge Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[KnowledgeAgent] Init completed.');\n        } catch (error) {\n            console.error('[KnowledgeAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Knowledge Agent.     * Performs database operations using the Supabase client.     * @param message The message to handle. Expected payload varies by type.     * @returns Promise<AgentResponse> The response containing the DB operation result or error.     */    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        console.log("], ["typescript\n// src/agents/KnowledgeAgent.ts\n// \\u77e5\\u8b58\\u5eab\\u4ee3\\u7406 (Knowledge Agent)\n// Handles operations related to the user's knowledge base.\n// Part of the Agent System Architecture.\n// Design Principle: Encapsulates knowledge management logic.\n// --- Modified: Add handler for ingest_external_knowledge message --\n// --- Modified: Pass context parameter in query_knowledge message handling --\n// --- Modified: Update handleMessage to delegate to MemoryEngine/KnowledgeSync/KnowledgeGraph/Glossary --\n// --- Modified: Update handleMessage to use requestAgent for RuneEngraftingCenter calls --\n// --- Modified: Update handleMessage to delegate synthesize_knowledge to WisdomSecretArt --\n// --- Modified: Ensure consistent error handling and logging --\n\n\nimport { SystemContext, KnowledgeRecord, GlossaryTerm, KnowledgeCollection, KnowledgeRelation } from '../../interfaces'; // Assuming SystemContext interface exists, Import GlossaryTerm, KnowledgeCollection, KnowledgeRelation\nimport { BaseAgent, AgentMessage, AgentResponse } from './BaseAgent'; // Import types\nimport { AgentFactory } from './AgentFactory'; // Import AgentFactory\n\n// Import existing services/agents this agent will interact with (temporarily)\n// In a full refactor, the logic from these services would move INTO this agent.\n// For MVP, this agent acts as a proxy to the existing services.\n// import { MemoryEngine } from '../core/memory/MemoryEngine'; // Access via context\n// import { KnowledgeSync } from '../modules/knowledgeSync'; // Access via context\n// import { WisdomSecretArt } from '../core/wisdom/WisdomSecretArt'; // Access via requestAgent\n// import { GlossaryService } from '../core/glossary/GlossaryService'; // Access via context\n// import { KnowledgeGraphService } from '../core/wisdom/KnowledgeGraphService'; // Access via context\n// import { SacredRuneEngraver } from '../core/rune-engrafting/SacredRuneEngraver'; // Access via requestAgent\n\n\nexport class KnowledgeAgent extends BaseAgent { // Extend BaseAgent\n    // private memoryEngine: MemoryEngine; // Access via context\n    // private knowledgeSync: KnowledgeSync; // Access via context\n    // private wisdomSecretArt: WisdomSecretArt; // Access via requestAgent\n    // private glossaryService: GlossaryService; // Access via context\n    // private knowledgeGraphService: KnowledgeGraphService; // Access via context\n    // private sacredRuneEngraver: SacredRuneEngraver; // Access via requestAgent\n\n\n    constructor(context: SystemContext) {\n        // --- Modified: Call super constructor with agent name ---\n        super('knowledge', context); // Call BaseAgent constructor with agent name 'knowledge'\n        // --- End Modified ---\n        // Services are accessed via context\n    }\n\n    /**\n     * Initializes the Knowledge Agent.\n     */\n    init(): void {\n        super.init(); // Call base init\n        try {\n            // Services are accessed via context, no need to get them here explicitly for MVP\n            console.log('[KnowledgeAgent] Init completed.');\n        } catch (error) {\n            console.error('[KnowledgeAgent] Failed during init:', error);\n            // Handle error\n        }\n    }\n\n\n    /**\n     * Handles messages directed to the Knowledge Agent.\\\n     * Performs database operations using the Supabase client.\\\n     * @param message The message to handle. Expected payload varies by type.\\\n     * @returns Promise<AgentResponse> The response containing the DB operation result or error.\\\n     */\\\n    protected async handleMessage(message: AgentMessage): Promise<AgentResponse> {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        console.log("]))[KnowledgeAgent];
Handling;
message: $;
{
    message.type;
}
(Correlation);
ID: $;
{
    message.correlationId || 'N/A';
}
");\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\\\\\\\\\\\\n        const userId = this.context.currentUser?.id;\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n        if (!userId) {\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n             // Return error response if user is not authenticated\\\\\\\\\\\\\\             return { success: false, error: 'User not authenticated.' };\\\\\\\\\\\\\\n        }\\\\\\\\\\\\\n\\\\\\n        try {\\\\\\\\\\\\\\\n            let result: any;\\\\\\\\\\\\\\\n            switch (message.type) {\\\\\\\\\\\\\\\n                case 'create_knowledge_point':\\\\\\\\\\\\\\\n                    // Payload is expected to be { question: string, answer: string, source?: string, devLogDetails?: any, is_starred?: boolean, tags?: string[] }\\\\\\\\\\\\\\\n                    if (!message.payload?.question || !message.payload?.answer) {\\\\\\\\\\\\\\\n                         // Return error response if required fields are missing\\\\\\\\\\\\\\\n                         return { success: false, error: 'Question and answer are required to create knowledge point.' };\\\\\\\\\\\\\\\n                    }\\\\\\\\\\\\\n                    // Delegate to MemoryEngine via KnowledgeSync\\\\\\\\\\\\\\\n                    result = await this.context.knowledgeSync?.saveKnowledge(\\\\\\\\\\\\\n                        message.payload.question,\\\\\\\\\\\\\n                        message.payload.answer,\\\\\\\\\\\\\\\n                        userId,\\\\\\\\\\\\\\\n                        message.payload.source,\\\\\\\\\\\\\\\n                        message.payload.devLogDetails,\\\\\\\\\\\\\\\n                        message.payload.is_starred, // Pass is_starred\\\\\\\\\\\\\\\n                        message.payload.tags // Pass tags\\\\\\\\\\\\\\\n                    );\\\\\\\\\\\\\\\n                    if (!result) {\\\\\\\\\\\\\\\n                         // Return error response if delegation failed\\\\\\\\\\\\\\\n                         return { success: false, error: 'Failed to save knowledge point via KnowledgeSync.' };\\\\\\\\\\\\\\\n                    }\\\\\\\\\\\\\n                    return { success: true, data: result };\\\\\\\\\\\\\\\n\\\\\\\\\\\\n                case 'query_knowledge':\\\\\\\\\\\\\\\n                    // Payload is expected to be { query: string, useSemanticSearch?: boolean, language?: string, context?: any }\\\\\\\\\\\\\\\n                     if (!message.payload?.query) {\\\\\\\\\\\\\\\n                         // Return error response if required fields are missing\\\\\\\\\\\\\\\n                         return { success: false, error: 'Query is required to query knowledge.' };\\\\\\\\\\\\\\\n                    }\\\\\\\\\\\\\n                    // Delegate to MemoryEngine via KnowledgeSync\\\\\\\\\\\\\\\n                    result = await this.context.knowledgeSync?.searchKnowledge(\\\\\\\\\\\\\n                        message.payload.query,\\\\\\\\\\\\\n                        userId,\\\\\\\\\\\\\\\n                        message.payload.useSemanticSearch,\\\\\\\\\\\\\\\n                        message.payload.language,\\\\\\\\\\\\\\\n                        message.payload.context // Pass the context parameter\\\\\\\\\\\\\\\n                    );\\\\\\\\\\\\\\\n                    // Result is an array of KnowledgeRecord (can be empty, not an error)\\\\\\\\\\\\\n                    return { success: true, data: result };\\\\\\\\\\\\\\\n\\\\\\n                case 'get_knowledge_by_id':\\\\\\\\\\\\\\\n                    // Payload is expected to be { id: string }\\\\\\\n                    if (!message.payload?.id) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'ID is required to get knowledge by ID.' };\\\\\\\n                    }\\                    // Delegate to MemoryEngine via KnowledgeSync (assuming KnowledgeSync has this method)\\                    // Note: KnowledgeSync currently doesn't have getKnowledgeById. MemoryEngine does.\\\n                    // Let's delegate directly to MemoryEngine for MVP.\\\n                    if (!this.context.memoryEngine) {\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\n                    }\\\n                    result = await this.context.memoryEngine.getKnowledgeById(message.payload.id, userId);\\\n                    if (!result) {\\\\\\                         // Return not found if record doesn't exist or not accessible\\\\\\                         return { success: false, error: ";
Knowledge;
record;
$;
{
    message.payload.id;
}
not;
found;
or;
not;
accessible.(__makeTemplateObject([" };\\\\\\                    }\\                    return { success: true, data: result };\\\\                case 'update_knowledge':\\                    // Payload is expected to be { id: string, updates: Partial<KnowledgeRecord> }\\                     if (!message.payload?.id || !message.payload?.updates) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'ID and updates are required to update knowledge.' };\\                    }\\                    // Delegate to MemoryEngine via KnowledgeSync\\                    result = await this.context.knowledgeSync?.updateKnowledge(\\                        message.payload.id,\\\n                        message.payload.updates,\\\n                        userId\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed (e.g., not found or not owned)\\                         return { success: false, error: 'Failed to update knowledge point (not found or not owned).' };\\                    }\\                    return { success: true, data: result };\\\\                case 'delete_knowledge':\\                    // Payload is expected to be { id: string }\\                     if (!message.payload?.id) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'ID is required to delete knowledge.' };\\                    }\\                    // Delegate to MemoryEngine via KnowledgeSync\\                    result = await this.context.knowledgeSync?.deleteKnowledge(\\                        message.payload.id,\\\n                        userId\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed (e.g., not found or not owned)\\                         return { success: false, error: 'Failed to delete knowledge point (not found or not owned).' };\\                    }\\                    return { success: true, data: { id: message.payload.id } }; // Return deleted ID\\\\                case 'synthesize_knowledge':\\                    // Payload is expected to be { recordIds?: string[], collectionId?: string, query?: string, options?: any }\\                    const { recordIds, collectionId, query: synthQuery, options } = message.payload;\\                    if (!recordIds && !collectionId) {\\                         // Return error response if knowledge source is missing\\                         return { success: false, error: 'Knowledge source (recordIds or collectionId) is required to synthesize knowledge.' };\\                    }\\\\                    let sourceRecords: KnowledgeRecord[] = [];\\                    // --- Modified: Delegate knowledge retrieval to MemoryEngine ---\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available for knowledge retrieval.' };\\                    }\\                    if (collectionId) {\\                        // Fetch records from the collection\\                        sourceRecords = await this.context.memoryEngine.getRecordsInCollection(collectionId, userId) || [];\\                    } else if (recordIds && recordIds.length > 0) {\\                        // Fetch specific records by ID (assuming MemoryEngine has a batch get method or iterate)\\                        // For MVP, iterate or use getAllKnowledgeForUser and filter\\                        const allRecords = await this.context.memoryEngine.getAllKnowledgeForUser(userId) || [];\\                        sourceRecords = allRecords.filter(record => recordIds.includes(record.id));\\                    }\\                    // --- End Modified ---\\\\                    if (sourceRecords.length === 0) {\\                         // Return error response if no source records found\\                         return { success: false, error: 'No source records found for synthesis.' };\\                    }\\\\                    // Delegate to WisdomSecretArt for synthesis\\                    // --- Modified: Use requestAgent for WisdomSecretArt call ---\\                    if (!this.context.agentFactory?.getAgent('wisdom')) {\\                         return { success: false, error: 'WisdomAgent not available for synthesis.' };\\                    }\\                    result = await this.requestAgent(\\                        'wisdom', // Target the WisdomAgent\\                        'synthesize_knowledge', // Message type for WisdomAgent\\                        { records: sourceRecords, query: synthQuery, options: options }, // Pass parameters\\                        60000 // Timeout for LLM synthesis\\                    ).then(response => {\\                         if (!response.success || !response.data) {\\                             throw new Error(response.error || 'WisdomAgent failed to return synthesized knowledge.');\\                         }\\                         return response.data; // Assuming WisdomAgent returns the synthesized data\\                    });\\                    // --- End Modified ---\\\\                    if (!result) {\\                         // Return error response if delegation failed\\                         return { success: false, error: 'Failed to synthesize knowledge via WisdomSecretArt.' };\\                    }\\                    return { success: true, data: result };\\\\                case 'suggest_glossary_term':\\                    // Payload is expected to be { term: Omit<GlossaryTerm, 'id' | 'creation_timestamp' | 'last_updated_timestamp'> }\\                    if (!message.payload?.term) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Term details are required to suggest glossary term.' };\\                    }\\                    // Delegate to GlossaryService\\                    if (!this.context.glossaryService) {\\                         return { success: false, error: 'GlossaryService is not available.' };\\                    }\\                    result = await this.context.glossaryService.createTerm(\\                        message.payload.term,\\\n                        userId, // Use userId from agent context\\                        message.payload.term.is_public // Pass isPublic status from suggestion\\                    );\\                    // Note: createTerm returns null if the term already exists (not an error)\\                    // We return success: true even if null, as the suggestion was processed.\\                    return { success: true, data: result };\\\\                // --- New: Handle Collection Management Messages ---\\                case 'create_collection':\\                    // Payload: { name: string, description?: string }\\                    if (!message.payload?.name) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Collection name is required.' };\\                    }\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.createCollection(\\                        message.payload.name,\\\n                        userId,\\\n                        message.payload.description\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed\\                         return { success: false, error: 'Failed to create collection via MemoryEngine.' };\\                    }\\                    return { success: true, data: result };\\\\                case 'get_collections':\\                    // Payload: {}\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.getCollections(userId);\\                    return { success: true, data: result };\\\\                case 'get_collection_by_id':\\                    // Payload: { collectionId: string }\\                    if (!message.payload?.collectionId) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Collection ID is required.' };\\                    }\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.getCollectionById(message.payload.collectionId, userId);\\                    if (!result) {\\                         // Return not found if collection doesn't exist or not accessible\\                         return { success: false, error: "], [" };\\\\\\\\\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'update_knowledge':\\\\\\\n                    // Payload is expected to be { id: string, updates: Partial<KnowledgeRecord> }\\\\\\\n                     if (!message.payload?.id || !message.payload?.updates) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'ID and updates are required to update knowledge.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine via KnowledgeSync\\\\\\\n                    result = await this.context.knowledgeSync?.updateKnowledge(\\\\\\\n                        message.payload.id,\\\\\n                        message.payload.updates,\\\\\n                        userId\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed (e.g., not found or not owned)\\\\\\\n                         return { success: false, error: 'Failed to update knowledge point (not found or not owned).' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'delete_knowledge':\\\\\\\n                    // Payload is expected to be { id: string }\\\\\\\n                     if (!message.payload?.id) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'ID is required to delete knowledge.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine via KnowledgeSync\\\\\\\n                    result = await this.context.knowledgeSync?.deleteKnowledge(\\\\\\\n                        message.payload.id,\\\\\n                        userId\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed (e.g., not found or not owned)\\\\\\\n                         return { success: false, error: 'Failed to delete knowledge point (not found or not owned).' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: { id: message.payload.id } }; // Return deleted ID\\\\\\\n\\\\\\\n                case 'synthesize_knowledge':\\\\\\\n                    // Payload is expected to be { recordIds?: string[], collectionId?: string, query?: string, options?: any }\\\\\\\n                    const { recordIds, collectionId, query: synthQuery, options } = message.payload;\\\\\\\n                    if (!recordIds && !collectionId) {\\\\\\\n                         // Return error response if knowledge source is missing\\\\\\\n                         return { success: false, error: 'Knowledge source (recordIds or collectionId) is required to synthesize knowledge.' };\\\\\\\n                    }\\\\\\\n\\\\\\\n                    let sourceRecords: KnowledgeRecord[] = [];\\\\\\\n                    // --- Modified: Delegate knowledge retrieval to MemoryEngine ---\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available for knowledge retrieval.' };\\\\\\\n                    }\\\\\\\n                    if (collectionId) {\\\\\\\n                        // Fetch records from the collection\\\\\\\n                        sourceRecords = await this.context.memoryEngine.getRecordsInCollection(collectionId, userId) || [];\\\\\\\n                    } else if (recordIds && recordIds.length > 0) {\\\\\\\n                        // Fetch specific records by ID (assuming MemoryEngine has a batch get method or iterate)\\\\\\\n                        // For MVP, iterate or use getAllKnowledgeForUser and filter\\\\\\\n                        const allRecords = await this.context.memoryEngine.getAllKnowledgeForUser(userId) || [];\\\\\\\n                        sourceRecords = allRecords.filter(record => recordIds.includes(record.id));\\\\\\\n                    }\\\\\\\n                    // --- End Modified ---\\\\\\\n\\\\\\\n                    if (sourceRecords.length === 0) {\\\\\\\n                         // Return error response if no source records found\\\\\\\n                         return { success: false, error: 'No source records found for synthesis.' };\\\\\\\n                    }\\\\\\\n\\\\\\\n                    // Delegate to WisdomSecretArt for synthesis\\\\\\\n                    // --- Modified: Use requestAgent for WisdomSecretArt call ---\\\\\\\n                    if (!this.context.agentFactory?.getAgent('wisdom')) {\\\\\\\n                         return { success: false, error: 'WisdomAgent not available for synthesis.' };\\\\\\\n                    }\\\\\\\n                    result = await this.requestAgent(\\\\\\\n                        'wisdom', // Target the WisdomAgent\\\\\\\n                        'synthesize_knowledge', // Message type for WisdomAgent\\\\\\\n                        { records: sourceRecords, query: synthQuery, options: options }, // Pass parameters\\\\\\\n                        60000 // Timeout for LLM synthesis\\\\\\\n                    ).then(response => {\\\\\\\n                         if (!response.success || !response.data) {\\\\\\\n                             throw new Error(response.error || 'WisdomAgent failed to return synthesized knowledge.');\\\\\\\n                         }\\\\\\\n                         return response.data; // Assuming WisdomAgent returns the synthesized data\\\\\\\n                    });\\\\\\\n                    // --- End Modified ---\\\\\\\n\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed\\\\\\\n                         return { success: false, error: 'Failed to synthesize knowledge via WisdomSecretArt.' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'suggest_glossary_term':\\\\\\\n                    // Payload is expected to be { term: Omit<GlossaryTerm, 'id' | 'creation_timestamp' | 'last_updated_timestamp'> }\\\\\\\n                    if (!message.payload?.term) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Term details are required to suggest glossary term.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to GlossaryService\\\\\\\n                    if (!this.context.glossaryService) {\\\\\\\n                         return { success: false, error: 'GlossaryService is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.glossaryService.createTerm(\\\\\\\n                        message.payload.term,\\\\\n                        userId, // Use userId from agent context\\\\\\\n                        message.payload.term.is_public // Pass isPublic status from suggestion\\\\\\\n                    );\\\\\\\n                    // Note: createTerm returns null if the term already exists (not an error)\\\\\\\n                    // We return success: true even if null, as the suggestion was processed.\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                // --- New: Handle Collection Management Messages ---\\\\\\\n                case 'create_collection':\\\\\\\n                    // Payload: { name: string, description?: string }\\\\\\\n                    if (!message.payload?.name) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Collection name is required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.createCollection(\\\\\\\n                        message.payload.name,\\\\\n                        userId,\\\\\n                        message.payload.description\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed\\\\\\\n                         return { success: false, error: 'Failed to create collection via MemoryEngine.' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'get_collections':\\\\\\\n                    // Payload: {}\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.getCollections(userId);\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'get_collection_by_id':\\\\\\\n                    // Payload: { collectionId: string }\\\\\\\n                    if (!message.payload?.collectionId) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Collection ID is required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.getCollectionById(message.payload.collectionId, userId);\\\\\\\n                    if (!result) {\\\\\\\n                         // Return not found if collection doesn't exist or not accessible\\\\\\\n                         return { success: false, error: "]));
Collection;
$;
{
    message.payload.collectionId;
}
not;
found;
or;
not;
accessible.(__makeTemplateObject([" };\\                    }\\                    return { success: true, data: result };\\\\                case 'get_records_in_collection':\\                    // Payload: { collectionId: string }\\                    if (!message.payload?.collectionId) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Collection ID is required.' };\\                    }\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.getRecordsInCollection(message.payload.collectionId, userId);\\                    return { success: true, data: result };\\\\                case 'add_record_to_collection':\\                    // Payload: { collectionId: string, recordId: string }\\                    if (!message.payload?.collectionId || !message.payload?.recordId) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Collection ID and Record ID are required.' };\\                    }\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.addRecordToCollection(\\                        message.payload.collectionId,\\\n                        message.payload.recordId,\\\n                        userId\\                    );\\                    // Note: addRecordToCollection returns null if already exists (not an error)\\                    return { success: true, data: result };\\\\                case 'remove_record_from_collection':\\                    // Payload: { collectionId: string, recordId: string }\\                    if (!message.payload?.collectionId || !message.payload?.recordId) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Collection ID and Record ID are required.' };\\                    }\\                    // Delegate to MemoryEngine\\                    if (!this.context.memoryEngine) {\\                         return { success: false, error: 'MemoryEngine is not available.' };\\                    }\\                    result = await this.context.memoryEngine.removeRecordFromCollection(\\                        message.payload.collectionId,\\\n                        message.payload.recordId,\\\n                        userId\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed (e.g., not found in collection)\\                         return { success: false, error: 'Record not found in collection or not accessible.' };\\                    }\\                    return { success: true, data: { collectionId: message.payload.collectionId, recordId: message.payload.recordId } }; // Return deleted IDs\\\\                // --- End New ---\\\\                // --- New: Handle Knowledge Graph Messages ---\\                case 'get_graph_data':\\                    // Payload: {}\\                    // Delegate to KnowledgeGraphService\\                    if (!this.context.knowledgeGraphService) {\\                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\                    }\\                    result = await this.context.knowledgeGraphService.getGraphData(userId);\\                    return { success: true, data: result };\\\\                case 'create_relation':\\                    // Payload: { sourceRecordId: string, targetRecordId: string, relationType: string, details?: any }\\                    if (!message.payload?.sourceRecordId || !message.payload?.targetRecordId || !message.payload?.relationType) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Source ID, Target ID, and Relation Type are required.' };\\                    }\\                    // Delegate to KnowledgeGraphService\\                    if (!this.context.knowledgeGraphService) {\\                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\                    }\\                    result = await this.context.knowledgeGraphService.createRelation(\\                        message.payload.sourceRecordId,\\\n                        message.payload.targetRecordId,\\\n                        message.payload.relationType,\\\n                        userId,\\\n                        message.payload.details\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed\\                         return { success: false, error: 'Failed to create relation.' };\\                    }\\                    return { success: true, data: result };\\\\                case 'delete_relation':\\                    // Payload: { relationId: string }\\                    if (!message.payload?.relationId) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Relation ID is required.' };\\                    }\\                    // Delegate to KnowledgeGraphService\\                    if (!this.context.knowledgeGraphService) {\\                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\                    }\\                    result = await this.context.knowledgeGraphService.deleteRelation(\\                        message.payload.relationId,\\\n                        userId\\                    );\\                    if (!result) {\\                         // Return error response if delegation failed (e.g., not found)\\                         return { success: false, error: 'Relation not found or not accessible.' };\\                    }\\                    return { success: true, data: { relationId: message.payload.relationId } }; // Return deleted ID\\\\                // --- End New ---\\\\                // --- New: Handle Ingest External Knowledge Message ---\\                case 'ingest_external_knowledge':\\                    // Payload: { source: string, query?: any, options?: any }\\                    if (!message.payload?.source) {\\                         // Return error response if required fields are missing\\                         return { success: false, error: 'Knowledge source is required for ingestion.' };\\                    }\\                    console.log("], [" };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'get_records_in_collection':\\\\\\\n                    // Payload: { collectionId: string }\\\\\\\n                    if (!message.payload?.collectionId) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Collection ID is required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.getRecordsInCollection(message.payload.collectionId, userId);\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'add_record_to_collection':\\\\\\\n                    // Payload: { collectionId: string, recordId: string }\\\\\\\n                    if (!message.payload?.collectionId || !message.payload?.recordId) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Collection ID and Record ID are required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.addRecordToCollection(\\\\\\\n                        message.payload.collectionId,\\\\\n                        message.payload.recordId,\\\\\n                        userId\\\\\\\n                    );\\\\\\\n                    // Note: addRecordToCollection returns null if already exists (not an error)\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'remove_record_from_collection':\\\\\\\n                    // Payload: { collectionId: string, recordId: string }\\\\\\\n                    if (!message.payload?.collectionId || !message.payload?.recordId) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Collection ID and Record ID are required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to MemoryEngine\\\\\\\n                    if (!this.context.memoryEngine) {\\\\\\\n                         return { success: false, error: 'MemoryEngine is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.memoryEngine.removeRecordFromCollection(\\\\\\\n                        message.payload.collectionId,\\\\\n                        message.payload.recordId,\\\\\n                        userId\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed (e.g., not found in collection)\\\\\\\n                         return { success: false, error: 'Record not found in collection or not accessible.' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: { collectionId: message.payload.collectionId, recordId: message.payload.recordId } }; // Return deleted IDs\\\\\\\n\\\\\\\n                // --- End New ---\\\\\\\n\\\\\\\n                // --- New: Handle Knowledge Graph Messages ---\\\\\\\n                case 'get_graph_data':\\\\\\\n                    // Payload: {}\\\\\\\n                    // Delegate to KnowledgeGraphService\\\\\\\n                    if (!this.context.knowledgeGraphService) {\\\\\\\n                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.knowledgeGraphService.getGraphData(userId);\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'create_relation':\\\\\\\n                    // Payload: { sourceRecordId: string, targetRecordId: string, relationType: string, details?: any }\\\\\\\n                    if (!message.payload?.sourceRecordId || !message.payload?.targetRecordId || !message.payload?.relationType) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Source ID, Target ID, and Relation Type are required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to KnowledgeGraphService\\\\\\\n                    if (!this.context.knowledgeGraphService) {\\\\\\\n                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.knowledgeGraphService.createRelation(\\\\\\\n                        message.payload.sourceRecordId,\\\\\n                        message.payload.targetRecordId,\\\\\n                        message.payload.relationType,\\\\\n                        userId,\\\\\n                        message.payload.details\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed\\\\\\\n                         return { success: false, error: 'Failed to create relation.' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: result };\\\\\\\n\\\\\\\n                case 'delete_relation':\\\\\\\n                    // Payload: { relationId: string }\\\\\\\n                    if (!message.payload?.relationId) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Relation ID is required.' };\\\\\\\n                    }\\\\\\\n                    // Delegate to KnowledgeGraphService\\\\\\\n                    if (!this.context.knowledgeGraphService) {\\\\\\\n                         return { success: false, error: 'KnowledgeGraphService is not available.' };\\\\\\\n                    }\\\\\\\n                    result = await this.context.knowledgeGraphService.deleteRelation(\\\\\\\n                        message.payload.relationId,\\\\\n                        userId\\\\\\\n                    );\\\\\\\n                    if (!result) {\\\\\\\n                         // Return error response if delegation failed (e.g., not found)\\\\\\\n                         return { success: false, error: 'Relation not found or not accessible.' };\\\\\\\n                    }\\\\\\\n                    return { success: true, data: { relationId: message.payload.relationId } }; // Return deleted ID\\\\\\\n\\\\\\\n                // --- End New ---\\\\\\\n\\\\\\\n                // --- New: Handle Ingest External Knowledge Message ---\\\\\\\n                case 'ingest_external_knowledge':\\\\\\\n                    // Payload: { source: string, query?: any, options?: any }\\\\\\\n                    if (!message.payload?.source) {\\\\\\\n                         // Return error response if required fields are missing\\\\\\\n                         return { success: false, error: 'Knowledge source is required for ingestion.' };\\\\\\\n                    }\\\\\\\n                    console.log("]))[KnowledgeAgent];
Initiating;
ingestion;
from;
external;
source: $;
{
    message.payload.source;
}
");\\                    // Delegate ingestion logic to a dedicated method or service\\                    // For MVP, simulate fetching from Capacities Rune and saving\\                    if (message.payload.source === 'capacities') {\\                        // --- Modified: Use requestAgent for RuneEngraftingAgent call ---\\                        if (!this.context.agentFactory?.getAgent('rune_engrafting')) {\\                            return { success: false, error: 'RuneEngraftingAgent not available for Capacities ingestion.' };\\                        }\\                        console.log('[KnowledgeAgent] Fetching data from Capacities Rune...');\\                        // Call the getObjects method on the Capacities Rune via RuneEngraftingAgent\\                        const runeResponse = await this.requestAgent(\\                            'rune_engrafting', // Target the RuneEngrafting Agent\\                            'execute_rune_action', // Message type for RuneEngrafting Agent\\                            {\\                                runeId: 'capacities-rune', // The specific Rune ID for Capacities\\                                action: 'getObjects', // The action to execute on the rune\\                                params: message.payload.query, // Pass query/options from payload to the rune\\                            },\\\n                            30000 // Timeout for rune execution\\                        );\\\\                        if (!runeResponse.success || !Array.isArray(runeResponse.data)) {\\                            throw new Error(runeResponse.error || 'Failed to fetch data from Capacities Rune.');\\                        }\\\\                        const capacitiesObjects = runeResponse.data;\\                        console.log("[KnowledgeAgent];
Received;
$;
{
    capacitiesObjects.length;
}
objects;
from;
Capacities.Saving;
to;
KB;
");\\\\                        // Save each object as a Knowledge Record\\                        const savedRecords: KnowledgeRecord[] = [];\\                        if (this.context.knowledgeSync) {\\                            for (const obj of capacitiesObjects) {\\                                try {\\                                    // Map Capacities object structure to KnowledgeRecord structure\\                                    const recordDetails: Omit<KnowledgeRecord, 'id' | 'timestamp'> = {\\                                        question: obj.title || ";
Capacities;
Object;
$;
{
    obj.id;
}
", // Use title as question\\                                        answer: obj.content || JSON.stringify(obj), // Use content or full object as answer\\                                        user_id: userId, // Associate with current user\\                                        source: ";
capacities: $;
{
    obj.type || 'object';
}
", // Source indicates origin and type\\                                        tags: [...(obj.tags || []), 'capacities'], // Add capacities tag\\                                        dev_log_details: { capacitiesId: obj.id, capacitiesType: obj.type }, // Store original ID/type\\                                    };\\                                    const savedRecord = await this.context.knowledgeSync.saveKnowledge(\\                                        recordDetails.question,\\\n                                        recordDetails.answer,\\\n                                        userId,\\\n                                        recordDetails.source,\\\n                                        recordDetails.dev_log_details,\\\n                                        recordDetails.is_starred,\\\n                                        recordDetails.tags\\                                    );\\                                    if (savedRecord) savedRecords.push(savedRecord);\\                                } catch (saveError: any) {\\                                    console.error("[KnowledgeAgent];
Failed;
to;
save;
Capacities;
object;
$;
{
    obj.id;
}
as;
Knowledge;
Record: ", saveError.message);\\                                    // Continue to next object even if one fails\\                                }\\                            }\\                        } else {\\                            console.warn('[KnowledgeAgent] KnowledgeSync not available to save ingested data.');\\                        }\\\\                        console.log("[KnowledgeAgent];
Ingestion;
from;
Capacities;
complete.Saved;
$;
{
    savedRecords.length;
}
records.(__makeTemplateObject([");\\                        result = { message: "], [");\\\\\\\n                        result = { message: "]));
Ingestion;
from;
Capacities;
complete.Saved;
$;
{
    savedRecords.length;
}
records.(__makeTemplateObject([", savedRecordsCount: savedRecords.length };\\                        return { success: true, data: result };\\\\                    } else {\\                         // Return error response for unsupported source\\                        return { success: false, error: "], [", savedRecordsCount: savedRecords.length };\\\\\\\n                        return { success: true, data: result };\\\\\\\n\\\\\\\n                    } else {\\\\\\\n                         // Return error response for unsupported source\\\\\\\n                        return { success: false, error: "]));
Unsupported;
external;
knowledge;
source;
for (ingestion; ; )
    : $;
{
    message.payload.source;
}
" };\\                    }\\\\                // --- End New ---\\\\\\                default:\\                    console.warn("[KnowledgeAgent];
Unknown;
message;
type: $;
{
    message.type;
}
");\\                    // Return error response for unknown message types\\                    return { success: false, error: ";
Unknown;
message;
type;
for (KnowledgeAgent; ; )
    : $;
{
    message.type;
}
" };\\            }\\        } catch (error: any) {\\            console.error("[KnowledgeAgent];
Error;
handling;
message;
$;
{
    message.type;
}
", error);\\            // Return error response for any caught errors\\            return { success: false, error: error.message || 'An error occurred in KnowledgeAgent.' };\\        }\\    }\\\\    // TODO: Implement methods to send messages to other agents if needed\\    // e.g., notifying SyncAgent after a local change\\    // protected sendSyncNotification(payload: any): void {\\    //     this.context.messageBus?.send({\\    //         type: 'knowledge_data_changed', // Custom event type\\    //         payload: payload,\\\n    //         sender: this.agentName,\\\n    //         // No recipient for a broadcast event\\\n    //     });\\\n    // }\\\n}\\\n"(__makeTemplateObject([""], [""]));
